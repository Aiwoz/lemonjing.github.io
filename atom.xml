<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TinyMood</title>
  <subtitle>写干净的文字，过简单的生活</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lemonjing.github.io/"/>
  <updated>2016-03-08T03:33:24.514Z</updated>
  <id>https://lemonjing.github.io/</id>
  
  <author>
    <name>Saber酱</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java-NIO概述</title>
    <link href="https://lemonjing.github.io/2016/03/07/Java-NIO%E6%A6%82%E8%BF%B0/"/>
    <id>https://lemonjing.github.io/2016/03/07/Java-NIO概述/</id>
    <published>2016-03-07T07:02:27.000Z</published>
    <updated>2016-03-08T03:33:24.514Z</updated>
    
    <content type="html">&lt;h1 id=&quot;Java-NIO：浅析I-O模型&quot;&gt;&lt;a href=&quot;#Java-NIO：浅析I-O模型&quot; class=&quot;headerlink&quot; title=&quot;Java NIO：浅析I/O模型&quot;&gt;&lt;/a&gt;Java NIO：浅析I/O模型&lt;/h1&gt;&lt;p&gt;NIO是Java 4里面提供的新的API，目的是用来解决传统IO的问题。&lt;/p&gt;
&lt;h2 id=&quot;为什么要使用-NIO&quot;&gt;&lt;a href=&quot;#为什么要使用-NIO&quot; class=&quot;headerlink&quot; title=&quot;为什么要使用 NIO?&quot;&gt;&lt;/a&gt;为什么要使用 NIO?&lt;/h2&gt;&lt;p&gt;NIO 的创建目的是为了让 Java 程序员可以实现高速 I/O 而无需编写自定义的本机代码。NIO 将最耗时的 I/O 操作(即填充和提取缓冲区)转移回操作系统，因而可以极大地提高速度。&lt;/p&gt;
&lt;h2 id=&quot;流与块的比较&quot;&gt;&lt;a href=&quot;#流与块的比较&quot; class=&quot;headerlink&quot; title=&quot;流与块的比较&quot;&gt;&lt;/a&gt;流与块的比较&lt;/h2&gt;&lt;p&gt;原来的 I/O 库(在 java.io.*中) 与 NIO 最重要的区别是数据打包和传输的方式。正如前面提到的，原来的 I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。&lt;/p&gt;
&lt;p&gt;面向流 的 I/O 系统一次一个字节地处理数据。一个输入流产生一个字节的数据，一个输出流消费一个字节的数据。为流式数据创建过滤器非常容易。链接几个过滤器，以便每个过滤器只负责单个复杂处理机制的一部分，这样也是相对简单的。不利的一面是，面向流的 I/O 通常相当慢。&lt;/p&gt;
&lt;p&gt;一个 面向块 的 I/O 系统以块的形式处理数据。每一个操作都在一步中产生或者消费一个数据块。按块处理数据比按(流式的)字节处理数据要快得多。但是面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性。&lt;/p&gt;
&lt;h2 id=&quot;NIO中的几个基础概念&quot;&gt;&lt;a href=&quot;#NIO中的几个基础概念&quot; class=&quot;headerlink&quot; title=&quot;NIO中的几个基础概念&quot;&gt;&lt;/a&gt;NIO中的几个基础概念&lt;/h2&gt;&lt;p&gt;在NIO中有几个比较关键的概念：Channel（通道），Buffer（缓冲区），Selector（选择器）。&lt;/p&gt;
&lt;p&gt;可以将NIO 中的Channel同传统IO中的Stream来类比，但是要注意，传统IO中，Stream是单向的，比如InputStream只能进行读取操作，OutputStream只能进行写操作。而Channel是双向的，既可用来进行读操作，又可用来进行写操作。Buffer（缓冲区），是NIO中非常重要的一个东西，在NIO中所有数据的读和写都离不开Buffer。&lt;/p&gt;
&lt;p&gt;NIO中最核心的一个东西：Selector。可以说它是NIO中最关键的一个部分，Selector的作用就是用来轮询每个注册的Channel，一旦发现Channel有注册的事件发生，便获取事件然后进行处理。&lt;br&gt;&lt;img src=&quot;http://images.cnitblog.com/i/288799/201408/181105032681855.jpg&quot; alt=&quot;Selector&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Channel&quot;&gt;&lt;a href=&quot;#Channel&quot; class=&quot;headerlink&quot; title=&quot;Channel&quot;&gt;&lt;/a&gt;Channel&lt;/h2&gt;&lt;p&gt;以下是常用的几种通道：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;FileChannel&lt;/li&gt;
&lt;li&gt;SocketChanel&lt;/li&gt;
&lt;li&gt;ServerSocketChannel&lt;/li&gt;
&lt;li&gt;DatagramChannel&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过使用FileChannel可以从文件读或者向文件写入数据；通过SocketChannel，以TCP来向网络连接的两端读写数据；通过ServerSocketChanel能够监听客户端发起的TCP连接，并为每个TCP连接创建一个新的SocketChannel来进行数据读写；通过DatagramChannel，以UDP协议来向网络连接的两端读写数据。&lt;/p&gt;
&lt;h2 id=&quot;Buffer&quot;&gt;&lt;a href=&quot;#Buffer&quot; class=&quot;headerlink&quot; title=&quot;Buffer&quot;&gt;&lt;/a&gt;Buffer&lt;/h2&gt;&lt;p&gt;Buffer，故名思意，缓冲区，实际上是一个容器，是一个连续数组。Channel提供从文件、网络读取数据的渠道，但是读取或写入的数据都必须经由Buffer。具体看下面这张图就理解了：&lt;br&gt;&lt;img src=&quot;http://images.cnitblog.com/i/288799/201408/181521285655283.jpg&quot; alt=&quot;Buffer&quot;&gt;&lt;/p&gt;
&lt;p&gt;在NIO中，Buffer是一个顶层父类，它是一个抽象类，常用的Buffer的子类有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ByteBuffer&lt;/li&gt;
&lt;li&gt;IntBuffer&lt;/li&gt;
&lt;li&gt;CharBuffer&lt;/li&gt;
&lt;li&gt;LongBuffer&lt;/li&gt;
&lt;li&gt;DoubleBuffer&lt;/li&gt;
&lt;li&gt;FloatBuffer&lt;/li&gt;
&lt;li&gt;ShortBuffer&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果是对于文件读写，上面几种Buffer都可能会用到。但是对于网络读写来说，用的最多的是ByteBuffer。&lt;/p&gt;
&lt;h2 id=&quot;Selector&quot;&gt;&lt;a href=&quot;#Selector&quot; class=&quot;headerlink&quot; title=&quot;Selector&quot;&gt;&lt;/a&gt;Selector&lt;/h2&gt;&lt;p&gt;Selector类是NIO的核心类，Selector能够检测多个注册的通道上是否有事件发生，如果有事件发生，便获取事件然后针对每个事件进行相应的响应处理。这样一来，只是用一个单线程就可以管理多个通道，也就是管理多个连接。这样使得只有在连接真正有读写事件发生时，才会调用函数来进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程，并且避免了多线程之间的上下文切换导致的开销。&lt;/p&gt;
&lt;p&gt;与Selector有关的一个关键类是SelectionKey，一个SelectionKey表示一个到达的事件，这2个类构成了服务端处理业务的关键逻辑。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java-NIO：浅析I-O模型&quot;&gt;&lt;a href=&quot;#Java-NIO：浅析I-O模型&quot; class=&quot;headerlink&quot; title=&quot;Java NIO：浅析I/O模型&quot;&gt;&lt;/a&gt;Java NIO：浅析I/O模型&lt;/h1&gt;&lt;p&gt;NIO是Java 4里面提供
    
    </summary>
    
      <category term="Java" scheme="https://lemonjing.github.io/categories/Java/"/>
    
    
      <category term="NIO" scheme="https://lemonjing.github.io/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>Stop Trying to Reinvent the Wheel</title>
    <link href="https://lemonjing.github.io/2016/03/04/86/"/>
    <id>https://lemonjing.github.io/2016/03/04/86/</id>
    <published>2016-03-04T02:57:29.000Z</published>
    <updated>2016-03-07T07:22:43.910Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;http://www.tinymood.com/wp-content/uploads/2016/03/2016030402540051.jpg&quot; alt=&quot;wheel&quot;&gt;&lt;br&gt;“不要重复造轮子 Stop Trying to Reinvent the Wheel”， 可能是每个程序员入行被告知的第一条准则。我自己也会对新人反复灌输这个概念，写程序其实是一个最能“偷懒”的工作：你现在费力实现的每一个功能，可能早已经有极好的解决方法贡献在开源社区，如果可以直接用现成的，那节省下来的时间是不是可以用来偷懒呢？极端的说法，哪怕是那位把所有开发外包给沈阳一家公司的哥们，如果撇开道德以及商业安全，只要能贡献优质的代码和健壮的功能，对于一个项目来说，这样做其实没任何问题。&lt;/p&gt;
&lt;h2 id=&quot;找轮子存在的问题&quot;&gt;&lt;a href=&quot;#找轮子存在的问题&quot; class=&quot;headerlink&quot; title=&quot;找轮子存在的问题&quot;&gt;&lt;/a&gt;找轮子存在的问题&lt;/h2&gt;&lt;p&gt;虽然不要重复造轮子的准则被反复提到，但是以我个人的经验，这个准则实践起来其实很有难度，因为：&lt;/p&gt;
&lt;p&gt;1.“不要重复造轮子”意味着首先需要找到一个可以用的轮子，而且我们一般希望是能最好的轮子才可以一劳永逸。这就对个人的信息检索能力有非常高的要求。&lt;/p&gt;
&lt;p&gt;2.找到了一个轮子，但这个轮子好不好用，需要时间来论证。能一眼判断一个项目的质量以及易用性，这其实需要大量项目经验的积累。&lt;/p&gt;
&lt;p&gt;3.好轮子不是你想用，想用就能用的。要想将一个开源项目整合到自己的项目中，需要对这个项目有比较深的了解。开源项目的文档质量参差不齐，当使用轮子时，只看文档往往是不够的，还需要阅读源代码甚至深度修改定制。更不要说大部分开源项目根本没有中文文档。&lt;/p&gt;
&lt;p&gt;所以现实情况往往是：新人不懂得检索方法，找不到轮子；好不容易找到一个轮子，学了半天不会用；好不容易能运行，很多地方与需求不一致，但是又不会改；一来二去，最后还是变成自己写轮子，同时还得出一个结论：别人的轮子都不好用，还是要坚持自己造轮子。&lt;/p&gt;
&lt;p&gt;这种情况的最佳体现，就是曾经有一段时间遍地开花的PHP框架。每一个写框架的人都认为自己写的框架才是最好的轮子，甚至是很多PHP新人，对几个成熟框架浅尝辄止后，也纷纷投身写框架的行列。成品大部分看过去却是大同小异，只是语法层面更符合作者本人的习惯，而缺乏大量的测试以及文档社区，最终的结果就是一个半成品然后无疾而终。&lt;/p&gt;
&lt;p&gt;这个例子可能有马后炮之嫌，毕竟PHP的造框架运动是由当时的背景和多方面的因素造成的，目前因为有了PHP-FIG制订的规范，PHP的框架的资源已经慢慢集中在Zend Framework、Symfony、CakePHP、Yii、CodeIgniter这样少数几个成熟框架之下了。更多的符合PSR规范的模块类库在取代新框架不断涌现，这对整个PHP社区都是好事情。&lt;/p&gt;
&lt;p&gt;话题稍微扯的有点远，不过核心的意思还是为了说明，找轮子本身其实是一件不容易的事情。而我对上面问题的解决方法是：找轮子的任务不要交给新人，而是要由经验丰富，信息检索能力强的编程人员负责，最好是项目的构架人员。团队成员找到的轮子最好也由构架人员拍板，用还是不用。对于团队新人，最重要的任务还是编程基本功、文档阅读能力以及如何用好已经拍板的轮子。&lt;/p&gt;
&lt;h2 id=&quot;怎样才算是好轮子？&quot;&gt;&lt;a href=&quot;#怎样才算是好轮子？&quot; class=&quot;headerlink&quot; title=&quot;怎样才算是好轮子？&quot;&gt;&lt;/a&gt;怎样才算是好轮子？&lt;/h2&gt;&lt;p&gt;个人认为好轮子应该具备以下的特征：&lt;/p&gt;
&lt;p&gt;1.开源，并且License宽松。&lt;/p&gt;
&lt;p&gt;2.有文档，代码规范，接口友好，最好有实际用例。&lt;/p&gt;
&lt;p&gt;3.社区相对活跃。&lt;/p&gt;
&lt;p&gt;4.松耦合，定制容易。&lt;/p&gt;
&lt;p&gt;至于同时找到好几个轮子需要选择的情况，可能要根据项目的实际情况进行取舍：有些轮子侧重于大而全，希望解决大部分问题，但是细节上处理不够细致；有些轮子小而精，专注解决一个问题，但是不具备好的通用性。但只要合适好用，都是一个好轮子。&lt;/p&gt;
&lt;h2 id=&quot;如何找到好轮子&quot;&gt;&lt;a href=&quot;#如何找到好轮子&quot; class=&quot;headerlink&quot; title=&quot;如何找到好轮子&quot;&gt;&lt;/a&gt;如何找到好轮子&lt;/h2&gt;&lt;p&gt;如何找到好轮子其实在上面问题中已经很清楚了，你应当具备：&lt;/p&gt;
&lt;p&gt;1.信息检索能力&lt;/p&gt;
&lt;p&gt;2.外文资料阅读能力&lt;/p&gt;
&lt;p&gt;3.代码阅读能力以及平时的积累&lt;/p&gt;
&lt;p&gt;对于第一条，个人的信息检索能力是无法一蹴而就的，不过如果是还在等待我对此再说出一二三而不是去自己检索寻找方法的朋友，基本上已经没救了。&lt;/p&gt;
&lt;p&gt;这里唯一需要说的是，如果想用百度那货去找技术资料的还是省省吧。&lt;/p&gt;
&lt;p&gt;外文资料阅读能力也非一日之功，不过个人倒是有个小窍门，如果想要获得一些项目的HelloWorld入门教程或者服务器的配置，可以将检索语言限定为日语，因为日文用户的教程往往秉承了日本细致入微的精神，包括项目背景、需要的环境安装等等一些对初学者才有用的知识，在日文的技术资料中往往也会写的很清楚。&lt;/p&gt;
&lt;p&gt;至于平时的积累，可能程序员都知道Github、SourceForge、Google Code这些优秀的项目托管网站。但是积累的意思并不是说有时间上去看两眼或者随便收藏一下这么简单。&lt;/p&gt;
&lt;p&gt;比如我自己侧重PHP方面的项目，我的一个做法是找到Github下所有Follower大于300的PHP项目（其实一共不到200个其中很多还是php框架），然后一个一个像扫货一样，对其进行了解以及记录。&lt;/p&gt;
&lt;p&gt;我的另一个做法是查看知名PHP框架，看看他们用了哪些轮子，比如在在Symfony Reference中，你就能淘到Assetic、monolog 这样的好货。&lt;/p&gt;
&lt;p&gt;最后一个办法是在Github上Follow一些活跃的作者，比如我的Following中就会显示我的Stars和Forks，里面自然也是我认为值得收藏关注的项目。&lt;/p&gt;
&lt;p&gt;本文章系转载，如有疑问请联系站长。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://www.tinymood.com/wp-content/uploads/2016/03/2016030402540051.jpg&quot; alt=&quot;wheel&quot;&gt;&lt;br&gt;“不要重复造轮子 Stop Trying to Reinvent the W
    
    </summary>
    
      <category term="业内" scheme="https://lemonjing.github.io/categories/%E4%B8%9A%E5%86%85/"/>
    
    
      <category term="GitHub" scheme="https://lemonjing.github.io/tags/GitHub/"/>
    
      <category term="轮子" scheme="https://lemonjing.github.io/tags/%E8%BD%AE%E5%AD%90/"/>
    
  </entry>
  
  <entry>
    <title>浅析网格计算与云计算</title>
    <link href="https://lemonjing.github.io/2016/03/04/63/"/>
    <id>https://lemonjing.github.io/2016/03/04/63/</id>
    <published>2016-03-04T02:40:05.000Z</published>
    <updated>2016-03-07T07:22:43.910Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;http://www.tinymood.com/wp-content/uploads/2016/03/2016030402394449.jpg&quot; alt=&quot;cloud&quot;&gt;&lt;br&gt;网格计算有了十几年的历史。网格基本形态是什么？是跨地区的，甚至跨国家的，甚至跨洲的这样一种独立管理的资源结合。资源在独立管理，并不是进行统一布置、统一安排的形态。网格这些资源都是异构的，不强调有什么统一的安排。另外网格的使用通常是让分布的用户构成虚拟组织（VO），在这样统一的网格基础平台上用虚拟组织形态从不同的自治域访问资源。此外，网格一般由所在地区、国家、国际公共组织资助的，支持的数据模型很广，从海量数据到专用数据以及到大小各异的临时数据集合，在网上传的数据，这是网格目前的基本形态。&lt;/p&gt;
&lt;h2 id=&quot;云计算与网格计算区别何在&quot;&gt;&lt;a href=&quot;#云计算与网格计算区别何在&quot; class=&quot;headerlink&quot; title=&quot;云计算与网格计算区别何在&quot;&gt;&lt;/a&gt;云计算与网格计算区别何在&lt;/h2&gt;&lt;p&gt;可以看出，网格计算和云计算有相似之处，特别是计算的并行与合作的特点；但他们的区别也是明显的。主要有以下几点：&lt;/p&gt;
&lt;p&gt;首先，网格计算的思路是聚合分布资源，支持虚拟组织，提供高层次的服务，例如分布协同科学研究等。而云计算的资源相对集中，主要以数据中心的形式提供底层资源的使用，并不强调虚拟组织（VO）的概念。&lt;/p&gt;
&lt;p&gt;其次，网格计算用聚合资源来支持挑战性的应用，这是初衷，因为高性能计算的资源不够用，要把分散的资源聚合起来；后来到了2004年以后，逐渐强调适应普遍的信息化应用，特别在中国，做的网格跟国外不太一样，就是强调支持信息化的应用。但云计算从一开始就支持广泛企业计算、Web应用，普适性更强。&lt;/p&gt;
&lt;p&gt;第三，在对待异构性方面，二者理念上有所不同。网格计算用中间件屏蔽异构系统，力图使用户面向同样的环境，把困难留在中间件，让中间件完成任务。而云计算实际上承认异构，用镜像执行，或者提供服务的机制来解决异构性的问题。当然不同的云计算系统还不太一样，像Google一般用比较专用的自己的内部的平台来支持。&lt;/p&gt;
&lt;p&gt;第四，网格计算用执行作业形式使用，在一个阶段内完成作用产生数据。而云计算支持持久服务，用户可以利用云计算作为其部分IT基础设施，实现业务的托管和外包。&lt;/p&gt;
&lt;p&gt;第五，网格计算更多地面向科研应用，商业模型不清晰。而云计算从诞生开始就是针对企业商业应用，商业模型比较清晰。&lt;/p&gt;
&lt;p&gt;总之，云计算是以相对集中的资源，运行分散的应用（大量分散的应用在若干大的中心执行）；而网格计算则是聚合分散的资源，支持大型集中式应用（一个大的应用分到多处执行）。但从根本上来说，从应对Internet的应用的特征特点来说，他们是一致的，为了完成在Internet情况下支持应用，解决异构性、资源共享等等问题。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://www.tinymood.com/wp-content/uploads/2016/03/2016030402394449.jpg&quot; alt=&quot;cloud&quot;&gt;&lt;br&gt;网格计算有了十几年的历史。网格基本形态是什么？是跨地区的，甚至跨国家的，甚至
    
    </summary>
    
      <category term="云计算" scheme="https://lemonjing.github.io/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
      <category term="云计算" scheme="https://lemonjing.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="网格计算" scheme="https://lemonjing.github.io/tags/%E7%BD%91%E6%A0%BC%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>『原创』计算机网络知识点连载</title>
    <link href="https://lemonjing.github.io/2016/02/29/32/"/>
    <id>https://lemonjing.github.io/2016/02/29/32/</id>
    <published>2016-02-29T13:53:51.000Z</published>
    <updated>2016-03-07T07:22:43.910Z</updated>
    
    <content type="html">&lt;h2 id=&quot;基本知识点&quot;&gt;&lt;a href=&quot;#基本知识点&quot; class=&quot;headerlink&quot; title=&quot;基本知识点&quot;&gt;&lt;/a&gt;基本知识点&lt;/h2&gt;&lt;p&gt;1.OSI参考模型（七层体系结构）&lt;/p&gt;
&lt;p&gt;物理层 - 数据链路层 - 网络层 - 运输层 - 会话层 - 表示层 - 应用层&lt;/p&gt;
&lt;p&gt;2.TCP/IP体系结构（四层体系结构）&lt;/p&gt;
&lt;p&gt;网络接口层 - 网际层IP - 运输层(TCP/UDP) - 应用层(FTP/SMTP/HTTP/TELNET…)&lt;/p&gt;
&lt;h2 id=&quot;物理层&quot;&gt;&lt;a href=&quot;#物理层&quot; class=&quot;headerlink&quot; title=&quot;物理层&quot;&gt;&lt;/a&gt;物理层&lt;/h2&gt;&lt;p&gt;1.奈氏准则&lt;/p&gt;
&lt;p&gt;理想低通信道最高码元传输速率 = 2W Baud（即每赫兹理想低通信道最高码元传输速率每秒2个码元）&lt;/p&gt;
&lt;p&gt;2.香农定理&lt;/p&gt;
&lt;p&gt;信道的极限传输速率C = Wlog2(1+S/N)，W为带宽，S为平均功率，N为高斯噪声功率，S/N也称为信噪比&lt;/p&gt;
&lt;p&gt;3.物理层之下的传输媒体&lt;/p&gt;
&lt;p&gt;双绞线 同轴电缆 光缆&lt;/p&gt;
&lt;p&gt;4.调制器和解调器&lt;/p&gt;
&lt;p&gt;调制器：基带数字信号波形转为模拟信号的波形&lt;/p&gt;
&lt;p&gt;解调器：将经过调制器变换的模拟信号恢复成原来的数字信号&lt;/p&gt;
&lt;p&gt;5.采样定理&lt;/p&gt;
&lt;p&gt;只要采样频率不低于电话信号最高频率的2倍，就可以从采样脉冲信号无失真地恢复出原来的电话信号。&lt;/p&gt;
&lt;p&gt;6.信道复用技术&lt;/p&gt;
&lt;p&gt;频分复用FDM 时分复用TDM&lt;/p&gt;
&lt;p&gt;码分多址CDMA：每个用户可以在同样的时间使用同样的频带进行通信。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color: #ff6600;&quot;&gt;7.单工 半双工 全双工&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;8.基带和宽带&lt;/p&gt;
&lt;p&gt;基带信号指将数字0,1直接用两种不同电压来表示，然后运到线路上传输。宽带信号指将基带信号调制后形成频分复用模拟信号。&lt;/p&gt;
&lt;p&gt;9.基带信号 - 曼彻斯特编码信号 - 差分曼彻斯特编码&lt;/p&gt;
&lt;p&gt;曼彻斯特编码：一个码元拆2个，码元1前高后低，码元0相反&lt;/p&gt;
&lt;p&gt;差分曼彻斯特编码：一个码元拆2个，码元1前半个与上一个码元的后半个一样，码元0相反。&lt;/p&gt;
&lt;h2 id=&quot;数据链路层&quot;&gt;&lt;a href=&quot;#数据链路层&quot; class=&quot;headerlink&quot; title=&quot;数据链路层&quot;&gt;&lt;/a&gt;数据链路层&lt;/h2&gt;&lt;p&gt;1.链路和数据链路（除了一条物理链路外还需要加一些通信协议控制数据的传输）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color: #ff6600;&quot;&gt;2.数据链路层3个基本问题 帧定界 透明传输 差错检测&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3.帧定界&lt;/p&gt;
&lt;p&gt;帧的数据部分的上限 &amp;lt;= MTU（最大传输单元），SOH（0x01）和EOT(0x04)分别指示帧的开始和结束。&lt;/p&gt;
&lt;p&gt;4.透明传输（数据的比特组合必须是不受限制的）&lt;/p&gt;
&lt;p&gt;方法1：字节插入&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.tinymood.com/wp-content/uploads/2016/02/2016022913455935.jpg&quot; alt=&quot;net1&quot;&gt;&lt;/p&gt;
&lt;p&gt;方法2：比特插入&lt;/p&gt;
&lt;p&gt;5.差错检测&lt;/p&gt;
&lt;p&gt;误码率：传输错误的比特与传输总比特数的比率&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CRC(Cyclic Redundancy Check)：循环冗余检验&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CRC是检错方法并不能纠错，FCS（Frame Check Sequence）是冗余码。&lt;/p&gt;
&lt;p&gt;计算冗余码（余数R）的方法：先补0（n个）再对生成多项式取模。&lt;/p&gt;
&lt;p&gt;CRC只能表示以接近1的概率认为它没有差错。但不能做到可靠传输。可靠传输还需要确认和重传机制。&lt;/p&gt;
&lt;p&gt;生成多项式P(X)：CRC-16，CRC-CCITT，CRC-32&lt;/p&gt;
&lt;p&gt;6.停止等待协议：解决死锁使用超时计时器。对重复帧的处理：丢弃，再次发送确认帧。向上面的网络层提供了可靠传输。是一种ARQ的差错检测方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7.发送窗口大于1的ARQ：连续ARQ和选择重传ARQ&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;连续ARQ又称Go-back-N ARQ，意思是出现差错必须重传时，要回走n个帧，即使是已经传送正确的数据帧也要重传。（仅因这些正确帧那面有一个错误）&lt;/p&gt;
&lt;p&gt;滑动窗口：（解决连续ARQ中一旦某个帧出错要重传之后许多帧，浪费时间，增大开销，因此我们对发出去但未被确认的帧的数目加以限制）包括发送窗口和接收窗口。为了减少开销，连续ARQ还执行捎带确认的机制。发送窗口Wt&amp;lt;= 2^n-1(n代表用几比特编号)，接收窗口Wr=1。&lt;/p&gt;
&lt;p&gt;选择重传ARQ：需要缓存空间，一般不使用。&lt;/p&gt;
&lt;p&gt;接收窗口Wr&amp;lt;=2^n/2 当接收窗口Wr为最大值时 Wt=Wr=2^n/2&lt;br&gt;这种收发两端窗口按规律向前移动，也称为滑动窗口协议。（连续ARQ，选择重传ARQ，停止等待都是）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6.PPP协议&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ppp帧格式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.tinymood.com/wp-content/uploads/2016/02/201602291346279.jpg&quot; alt=&quot;net2&quot;&gt;&lt;br&gt;注：当协议字段为0x0021时，信息字段为IP数据报，不超过1500字节&lt;/p&gt;
&lt;p&gt;字节填充：转义符为0x7D&lt;/p&gt;
&lt;p&gt;0比特填充：5个连续的1插入1个0&lt;/p&gt;
&lt;p&gt;7.HDLC协议：可以实现可靠传输&lt;/p&gt;
&lt;h2 id=&quot;局域网&quot;&gt;&lt;a href=&quot;#局域网&quot; class=&quot;headerlink&quot; title=&quot;局域网&quot;&gt;&lt;/a&gt;局域网&lt;/h2&gt;&lt;p&gt;1.按网络拓扑结构分：星形网、环形网（令牌环形网）、总线网、树形网。&lt;/p&gt;
&lt;p&gt;2.以太网&lt;/p&gt;
&lt;p&gt;DIX EthernetV2以太网标准成为主流&lt;/p&gt;
&lt;p&gt;802的数据链路层划分：逻辑链路控制LLC子层 + 媒体接入控制MAC子层&lt;/p&gt;
&lt;p&gt;以太网提供的服务是不可靠的交付，即尽最大努力交付。因为采用无连接，数据帧不编号，也不要求对方确认。对有差错的帧的重传有高层来决定。&lt;/p&gt;
&lt;p&gt;CSMA/CD协议(Carrier Sense Multiple Access with Collision Detection)：载波监听多点接入/碰撞检测&lt;/p&gt;
&lt;p&gt;用于协调同一时间只能允许一台计算机发送信息，否则就会相互干扰的问题。&lt;/p&gt;
&lt;p&gt;电磁波在1km电缆的传播时延约5us。使用CSMA/CD协议，一个站不能同时发送和接收，因此不能实现全双工。&lt;/p&gt;
&lt;p&gt;争用期：2τ 51.2us 最短有效帧长为64字节&lt;/p&gt;
&lt;p&gt;截断二进制指数退避算法：基本退避时间了2τ k=min{重传次数，10} r=random(0~2^k-1) 重传所需时延为r倍的基本退避时间&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.MAC帧格式（以太网V2）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.tinymood.com/wp-content/uploads/2016/02/2016022913470267.jpg&quot; alt=&quot;net3&quot;&gt;&lt;br&gt;4.VLAN&lt;/p&gt;
&lt;p&gt;局域网网段构成的与物理位置无关的逻辑组。克服了广播风暴&lt;/p&gt;
&lt;p&gt;5.快速以太网参数a=τC/L。a为总线的单程传播时延和帧的发送时延之比 C为数据率 L为帧长，a远小于1，信道利用率越高&lt;/p&gt;
&lt;p&gt;6.无线网CSMA/CA&lt;/p&gt;
&lt;h2 id=&quot;城域网&quot;&gt;&lt;a href=&quot;#城域网&quot; class=&quot;headerlink&quot; title=&quot;城域网&quot;&gt;&lt;/a&gt;城域网&lt;/h2&gt;&lt;p&gt;网络层提供的服务：无连接的数据报和面向连接的虚电路&lt;/p&gt;
&lt;p&gt;数据报优点：128字节作为一个分组，迅速经济。主机承担端到端的差错控制和流量控制。&lt;/p&gt;
&lt;p&gt;虚电路：每个分组无需携带完整的目的地址，分组按顺序交付，网络负责差错控制和流量控制。&lt;/p&gt;
&lt;p&gt;使用默认路由简化转发表。&lt;/p&gt;
&lt;p&gt;拥塞：Σ对资源的需求 &amp;gt; 可用资源&lt;/p&gt;
&lt;p&gt;拥塞控制是一个全局性的过程，涉及到所有主机路由器。 流量控制往往指端到端之间点对点通信量的控制。&lt;/p&gt;
&lt;p&gt;拥塞过程：轻度拥塞 - 拥塞 - 死锁（直接死锁，重装死锁：因为路由器缓存引起的拥塞）&lt;/p&gt;
&lt;p&gt;ATM（异步传递方式）：建立在电路交换和分组交换的基础上一种面向连接的快速分组交换技术。&lt;/p&gt;
&lt;h2 id=&quot;网络层（IP层）&quot;&gt;&lt;a href=&quot;#网络层（IP层）&quot; class=&quot;headerlink&quot; title=&quot;网络层（IP层）&quot;&gt;&lt;/a&gt;网络层（IP层）&lt;/h2&gt;&lt;p&gt;1.中继（中间设备）：&lt;/p&gt;
&lt;p&gt;物理层中继系统：转发器 数据链路层中继系统：网桥或桥接器 网络层中继系统：路由器 网络层以上的中继系统：网关。由于历史原因，TCP/IP的文献中将路由器称为网关。&lt;/p&gt;
&lt;p&gt;2.协议：IP协议及与之配套的4个协议&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ARP（Address Resolution Protocol）地址解析协议：IP地址 -&amp;gt; MAC地址 RARP（Reverse Address Resolution Protocol）逆地址解析协议：MAC地址 -&amp;gt; IP地址 ICMP（Internet Control Message Protocol）因特网控制报文协议 IGMP（Internet Group Management Protocol）因特网组管理协议&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3.IP地址分类：1.基本分类的IP地址（两级） 2.子网的划分（三级） 3.无分类编址（构造超网）&lt;/p&gt;
&lt;p&gt;4.IP地址使用范围：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.tinymood.com/wp-content/uploads/2016/02/2016022913473653.jpg&quot; alt=&quot;net4&quot;&gt;&lt;br&gt;注：1.主机数减2的原因是因为主机号全0代表该IP地址是本主机所连接到的单个网络地址；主机号全1代表本网络上的所有主机。 注：2.A类地址网络数-2的原因是：第一，网络号全0是个保留地址代表本网络；第二，网络号为127（01111111）保留为本地软件环回测试。&lt;/p&gt;
&lt;p&gt;注1：D类IP地址网络号固定位为1110 用于多播；E类IP地址网络号固定位为11110，为保留地址。&lt;/p&gt;
&lt;p&gt;5.IP地址和硬件地址&lt;/p&gt;
&lt;p&gt;网络层的IP数据报交给数据链路层被封装成MAC帧，MAC帧的源地址和目的地址变为硬件地址&lt;/p&gt;
&lt;p&gt;6.ARP（IP地址 -&amp;gt; MAC地址）&lt;/p&gt;
&lt;p&gt;使用IP地址并不能直接用来通信，因为IP地址只是主机在抽象的网络层中的地址。最终要传到数据链路层封装成MAC帧才能发送到实际的网络。 因此不管使用什么协议最终需要的还是硬件地址。&lt;/p&gt;
&lt;p&gt;每个主机拥有一个ARP高速缓存（存放所在局域网内主机和路由器的IP地址到硬件地址的映射表）&lt;/p&gt;
&lt;p&gt;举例：A发送B (1).A在ARP Cache中查到B的MAC地址，写入MAC帧发往此B&lt;/p&gt;
&lt;p&gt;(2).没查到，A向本局域网广播ARP请求分组，内容包括自己的地址映射和B的IP地址&lt;/p&gt;
&lt;p&gt;(3).B发送ARP响应分组并写入A的映射（单播的方式）&lt;/p&gt;
&lt;p&gt;ARP Cache映射项目具有一个生存时间。&lt;/p&gt;
&lt;p&gt;7.IP数据报格式&lt;/p&gt;
&lt;p&gt;固定部分 20字节&lt;/p&gt;
&lt;p&gt;版本 - 首部长度 - 服务类型 - 总长度 - 标识 - 标志 - 片偏移 - 生存时间 - 协议 - 首部检验和 - 源地址4B - 目的地址4B - 可变部分4B&lt;/p&gt;
&lt;p&gt;标识：一个计数器，用来产生数据报的标识。&lt;/p&gt;
&lt;p&gt;标志字段：3位 MF=1后面还有分片 DF=0允许分片&lt;/p&gt;
&lt;p&gt;IP分片 MF DF 片偏移&lt;/p&gt;
&lt;p&gt;协议：占1个字节&lt;/p&gt;
&lt;p&gt;首部检验和：反码算数运算，不采用CRC&lt;/p&gt;
&lt;p&gt;8.划分子网：IP地址：网络号 - &amp;lt;子网号 - 主机号&amp;gt;（子网号是在两级分类编址中的主机号中划出的）&lt;/p&gt;
&lt;p&gt;子网掩码：网络号子网号置1(相当于CIDR中的网络前缀)主机号置0，这样子网掩码与IP地址相与即可算出网络地址。&lt;/p&gt;
&lt;p&gt;划分子网下的路由器转发算法：&lt;/p&gt;
&lt;p&gt;（1）从收到的数据报的首部提取目的IP地址D&lt;/p&gt;
&lt;p&gt;（2）先判断是否为直接交付。对与路由器相邻的子网进行检查。用各网络子网掩码与D相与，查看是否匹配。若是，直接交付（D 转化为物理地址，数据报封装成帧发送出去。）转发结束。若否，为间接交付，执行（3）&lt;/p&gt;
&lt;p&gt;（3）若路由表中有目的地址D的特定主机路由，则将数据报传给该路由，否则，执行（4）&lt;/p&gt;
&lt;p&gt;（4）对路由表的每一行（目的网络地址、子网掩码、下一跳地址），将其中的子网掩码与D相与，结果为N。若N与该行目的网络地址匹配，则 将该数据报传给该行指明的下一跳路由器，否则，执行（5）&lt;/p&gt;
&lt;p&gt;（5）若路由表中有一个默认路由，则传给默认路由，否则，执行（6）&lt;/p&gt;
&lt;p&gt;（6）报告分组转发出错&lt;/p&gt;
&lt;p&gt;9.无分类编址CIDR（CLassless Inter-Domain Routing 无分类域间路由选择）&lt;/p&gt;
&lt;p&gt;无分类的两级编址：格式 &amp;lt;网络前缀 - 主机号&amp;gt;&lt;/p&gt;
&lt;p&gt;路由聚合也称为构造超网因为一个CIDR地址块可以表示很多地址。&lt;/p&gt;
&lt;p&gt;最长前缀匹配：从匹配结果中选择具有最长网络前缀的路由&lt;/p&gt;
&lt;p&gt;10.ICMP（Internet Control Message Protocol）因特网控制报文协议&lt;/p&gt;
&lt;p&gt;包括ICMP差错报文和ICMP询问报文&lt;/p&gt;
&lt;p&gt;ICMP差错报文的类型：终点不可达 源点抑制 时间超过 参数问题 改变路由&lt;/p&gt;
&lt;p&gt;ICMP询问报文的类型：回送请求和回答 时间戳请求和回答 掩码地址请求和回答 路由器询问或通告&lt;/p&gt;
&lt;p&gt;应用层服务Ping使用了ICMP回送请求和回答报文，是应用层直接使用网络层ICMP的例子。没有通过运输层的TCP或UDP&lt;/p&gt;
&lt;p&gt;11.路由选择协议&lt;/p&gt;
&lt;p&gt;自治系统AS：自治系统有权自主地决定在本系统类采用何种路由选择协议。&lt;/p&gt;
&lt;p&gt;路由选择协议分为两类：&lt;strong&gt;内部网关协议IGP（Interior Gateway Protocol）主要有RIP和OSPF&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;外部网关协议EGP（External Gateway Protocol）主要是BGP-4&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;RIP（Routing Information Protocol）：分布式的基于距离向量的路由选择协议&lt;/p&gt;
&lt;p&gt;RIP的距离也称为跳数，RIP允许一条路径上最多包含15个路由器，因此距离为16相当于不可达。&lt;/p&gt;
&lt;p&gt;RIP仅和相邻路由交换信息，交换的是当前路由器知道的全部信息，即自己的路由表。按固定的时间间隔交换。&lt;/p&gt;
&lt;p&gt;RIP协议是收敛的，所谓收敛指自治系统中的所有结点都得到正确的路由选择信息的过程。最终使得每一个路由器到 每一个目的网络的路由都是最短的。&lt;/p&gt;
&lt;p&gt;优点：实习Ian简单，开销简单。缺点：“好消息传得快，坏消息传得慢”。&lt;/p&gt;
&lt;p&gt;RIP使用运输层UDP（520端口）进行传送，因此RIP的位置在应用层。但转发用户数据报的过程在网络层完成的。&lt;/p&gt;
&lt;p&gt;OSPF（Open Shortest Path First开放最短路径优先）：分布式的基于链路状态协议&lt;/p&gt;
&lt;p&gt;1.使用洪范法向本自治系统内所有路由器发送信息。&lt;/p&gt;
&lt;p&gt;2.发送的信息是与本路由器相邻的所有路由器的链路状态。&lt;/p&gt;
&lt;p&gt;3.只有链路状态发生变化时，路由器才使用洪泛法向所有路由器发送信息（而RIP是不管网络拓扑有无变化，路由器间都要定期交换路由表信息）&lt;/p&gt;
&lt;p&gt;由于频繁交换链路状态信息，因此所有路由器最终都能建立一个链路状态数据库，这个数据库实际上就是全网的拓扑结构图，在全网范围内是一致的。&lt;/p&gt;
&lt;p&gt;OSPF更新过程收敛的快。&lt;/p&gt;
&lt;p&gt;OSPF不用UDP而直接用IP数据报发送。可见OSPF的位置在网络层。&lt;/p&gt;
&lt;p&gt;负载均衡：在代价相同的路径上分配通信量，这叫多路径间的负载均衡。&lt;/p&gt;
&lt;p&gt;外部网关协议BGP（Border Gateway Protocol:边界网关协议）：基于路径向量路由选择协议。&lt;/p&gt;
&lt;p&gt;目标：力求选择一条比较好的路由。并非寻找最佳。&lt;/p&gt;
&lt;p&gt;BGP发言人需要建立TCP连接（端口179），然后在此连接上交换报文以建立BGP会话。&lt;/p&gt;
&lt;p&gt;BGP发言人需要同时运行BGP协议和内部网关协议&lt;/p&gt;
&lt;p&gt;BGP解决了基于距离向量路由选择算法中的“好消息传得快，坏消息传得慢”这一问题。&lt;/p&gt;
&lt;p&gt;BGP-4一共4种报文：打开包文 更新报文 保活报文 通知报文&lt;/p&gt;
&lt;p&gt;12.IGMP（因特网组管理协议）&lt;/p&gt;
&lt;p&gt;13.虚拟专用网&lt;/p&gt;
&lt;p&gt;专用地址&lt;/p&gt;
&lt;p&gt;10.0.0.0 - 10.255.255.255&lt;br&gt;172.16.0.0 - 172.31.255.255&lt;br&gt;192.168.0.0 - 192.168.255.255&lt;/p&gt;
&lt;p&gt;这些IP地址在本机构内部使用，也叫可重用地址。&lt;/p&gt;
&lt;p&gt;隧道技术实现虚拟专用网VPN（Virtual Private Network）&lt;/p&gt;
&lt;p&gt;分类:内联网VPN 外联网VPN&lt;/p&gt;
&lt;p&gt;内联网外联网都采用TCP/IP&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;14.NAT（Network Address Translation）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用本地地址的主机在和外界通信时都要在NAT路由器上将本地地址转换成全球地址。&lt;/p&gt;
&lt;p&gt;15.解决IP地址耗尽的方法&lt;/p&gt;
&lt;p&gt;（1）采用无分类编址CIDR，使IP地址分类更合理&lt;br&gt;（2）采用NAT转换&lt;br&gt;（3）IPv6&lt;br&gt;16.在网络层，IP数据报的首部检验和字段只检验首部是否出差错而不检验数据部分。&lt;/p&gt;
&lt;h2 id=&quot;运输层&quot;&gt;&lt;a href=&quot;#运输层&quot; class=&quot;headerlink&quot; title=&quot;运输层&quot;&gt;&lt;/a&gt;运输层&lt;/h2&gt;&lt;p&gt;运输层提供应用进程间的逻辑通信。它使应用进程看见的就好像是在两个运输层实体间一条端到端的逻辑通信信道。&lt;/p&gt;
&lt;p&gt;当运输层采用TCP时，尽管下面的网络是不可靠的，但这种逻辑通信信道相当于一条全双工的可靠信道。可以做到报文的无差错、 按序、无丢失、无重复。&lt;/p&gt;
&lt;p&gt;单单面向连接只是可靠的必要条件，不充分。还需要其他措施，如确认重传，按序接收，无丢失无重复。&lt;/p&gt;
&lt;p&gt;熟知端口：&lt;/p&gt;
&lt;p&gt;20 FTP数据连接&lt;br&gt;21 FTP控制连接&lt;br&gt;22 SSH&lt;br&gt;23 TELNET&lt;br&gt;25 SMTP&lt;br&gt;53 DNS&lt;br&gt;69 TFTP&lt;br&gt;80 HTTP&lt;br&gt;161 SNMP&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color: #ff0000;&quot;&gt;UDP重要&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;UDP的优点：&lt;/p&gt;
&lt;p&gt;1.发送之前无需建立连接，减小了开销和发送数据的时延&lt;/p&gt;
&lt;p&gt;2.UDP不使用拥塞控制，不使用可靠交付，因此主机不需要维护复杂的参数表、连接状态表&lt;/p&gt;
&lt;p&gt;3.UDP用户数据报只有8个字节的首部开销，而TCP要20字节。&lt;/p&gt;
&lt;p&gt;4.由于没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（IP电话等实时应用要求源主机以恒定的速率发送数据）&lt;/p&gt;
&lt;p&gt;Table，使用TCP和UDP的应用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.tinymood.com/wp-content/uploads/2016/02/2016022913481796.jpg&quot; alt=&quot;net5&quot;&gt;&lt;br&gt;注：TFTP：Trivial File Transfer Protocol&lt;/p&gt;
&lt;p&gt;UDP的过程：&lt;/p&gt;
&lt;p&gt;1.服务器进程运行着，等待TFTP客户进程的服务请求。客户端TFTP进程启动时，向操作系统申请一个临时端口号，然后操作系统为该进程创建2个队列， 入队列和出队列。只要进程在执行，2个队列一直存在。&lt;/p&gt;
&lt;p&gt;2.客户进程将报文发送到出队列中。UDP按报文在队列的先后顺序发送。在传送到IP层前给报文加上UDP首部，其中目的端口后为69。然后发给IP层。 出队列若溢出，则操作系统通知应用层TFTP客户进程暂停发送。&lt;/p&gt;
&lt;p&gt;3.客户端收到来自IP层的报文时，UDP检查报文中目的端口号是否正确，若正确，放入入队列队尾，客户进程按先后顺序一一取走。若不正确，UDP丢弃该报文，并请ICMP发送”端口不可达“差错报文给服务器端。入队列可能会溢出，若溢出，UDP丢弃该报文，不通知对方。&lt;/p&gt;
&lt;p&gt;服务器端类似。&lt;/p&gt;
&lt;p&gt;UDP首部：源端口 - 目的端口 - 长度 - 检验和，每个字段22字节。&lt;/p&gt;
&lt;p&gt;IP数据报检验和只检验IP数据报的首部，而UDP的检验和将首部和数据部分一起都检验。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color: #ff0000;&quot;&gt;TCP重要&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;TCP报文段是面向字节的数据流。&lt;/p&gt;
&lt;p&gt;TCP首部：20字节固定首部&lt;/p&gt;
&lt;p&gt;确认比特ACK，ACK=1 确认号字段才有效；同步比特SYN：SYN=1 ACK=0表示一个连接请求报文段；终止比特FIN，FIN=1时要求释放连接。&lt;/p&gt;
&lt;p&gt;窗口：A根据TCP缓存空间的大小确定自己的接收窗口大小。A发送给B的窗口字段写入该值。作为B的发送窗口的上限。&lt;/p&gt;
&lt;p&gt;选项：最大报文段长度MSS，MSS告诉对方TCP：我的缓存所能接收的报文段的数据字段的最大长度是MSS个字节。若主机未填写，默认为536字节。&lt;/p&gt;
&lt;p&gt;TCP的可靠是使用了序号和确认。存放副本。&lt;/p&gt;
&lt;p&gt;TCP报文段的发送时机：1.维持一个变量等于MSS，缓存达到就发送 2.发送端应用进程指明要发送，即TCP支持的PUSH操作。3.设定计时器&lt;/p&gt;
&lt;p&gt;接收端根据自身资源情况控制发送端发送窗口的大小。&lt;/p&gt;
&lt;p&gt;接收端窗口rwnd（receiver window）：接收端根据目前接收缓存大小设置的窗口值，是来自接收端的流量控制&lt;/p&gt;
&lt;p&gt;拥塞窗口cwnd（congestion window）：是发送端根据自己估计的网络拥塞程度设置的窗口值，是来自发送端的流量控制&lt;/p&gt;
&lt;p&gt;发送端的窗口=Min(rwnd, cwnd)&lt;/p&gt;
&lt;p&gt;慢开始算法：cwnd设置为1个MSS，每收到一个确认，将cwnd+1，逐步增大cwnd，使分组注入网络的速率更加合理。&lt;/p&gt;
&lt;p&gt;慢开始门限：ssthresh，当cwnd &amp;lt; ssthresh,执行慢开始算法；cwnd &amp;gt; ssthresh，改用拥塞避免算法。 cwnd = ssthresh时，都可以。&lt;/p&gt;
&lt;p&gt;拥塞避免算法使发送端的拥塞窗口每经过一个RTT增加一个MSS（而不管在此期间收到多少ACK），这样，拥塞窗口cwnd按线性规律增长，比 慢开始算法拥塞窗口增长速率缓慢很多。（加法增大）&lt;/p&gt;
&lt;p&gt;无论是慢开始还是拥塞避免，只要发送端发现网络出现拥塞（根据是没有按时收到ACK或者收到重复ACK），就开始将慢开始门限ssthresh设置为 出现拥塞时拥塞窗口值的一半。拥塞窗口cwnd置为1，执行慢开始算法。(乘法减小)&lt;/p&gt;
&lt;p&gt;上述TCP确认都是通过捎带确认执行的。&lt;/p&gt;
&lt;p&gt;快重传：发送端一连收到三个重复的ACK,即可断定分组丢失，不必等待重传计数器，立即重传丢失的报文。&lt;/p&gt;
&lt;p&gt;快恢复：当发送端收到3个重复的ACK时，乘法减小，ssthresh变为一半。但是cwnd不是置为1，而是ssthresh+3MSS。若收到的重复ACK 为n(n &amp;gt; 3)，则cwnd=ssthresh+nMSS.在使用快恢复算法时，慢开始算法只在TCP连接建立时使用。若收到了确认新的报文段的ACK，就将&lt;/p&gt;
&lt;p&gt;TCP的重传机制&lt;/p&gt;
&lt;p&gt;每发送一个报文段，就对这个报文段设置一次计时器。新的重传时间=γ*旧的重传时间。&lt;/p&gt;
&lt;p&gt;TCP连接建立和释放的过程&lt;/p&gt;
&lt;p&gt;SYN置1和FIN的报文段要消耗一个序号。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #ff6600;&quot;&gt;客户端连接状态变迁：CLOSED -&amp;gt; 主动打开,发送SYN=1 -&amp;gt; SYN_SENT -&amp;gt; 收到服务器的SYN=1和ACK时,发送三次握手的最后一个ACK -&amp;gt; ESTABLISHED -&amp;gt; 数据传送 -&amp;gt; 主动关闭 -&amp;gt; 发送FIN=1,等待确认ACK的到达 -&amp;gt; FIN_WAIT_1 -&amp;gt; 收到确认ACK后时，一向连接关闭 -&amp;gt; FIN_WAIT_2 -&amp;gt;收到服务器发送的FIN=1报文，响应，发送四次挥手的的最后一个确认ACK -&amp;gt; 这时另一条连接也关闭了，进入TIME_WAIT状态 -&amp;gt; 经过2倍报文寿命，TCP删除连接记录 -&amp;gt; 回到CLOSED状态&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #ff6600;&quot;&gt;服务器端连接状态变迁：CLOSED -&amp;gt; 被动打开 -&amp;gt; LISTEN -&amp;gt; 收到SYN=1的报文，发送SYN=1和确认ACK -&amp;gt; 进入SYN_RCVD -&amp;gt; 收到三次握手 的最后一个确认ACK -&amp;gt; ESTABLISHED -&amp;gt; 数据传送 -&amp;gt; 数据传送完毕，收到FIN=1 -&amp;gt; 发送确认ACK并进入CLOSED_WAIT -&amp;gt; 发送FIN=1给客户端 -&amp;gt; LAST_ACK -&amp;gt; 收到客户端的ACK -&amp;gt; 删除连接记录 -&amp;gt; 回到CLOSED状态&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;应用层&lt;/p&gt;
&lt;p&gt;1.DNS&lt;/p&gt;
&lt;p&gt;2.电子邮件：用户代理，邮件服务器，协议 其中SMTP用于发送邮件，POP3用于接收邮件。&lt;/p&gt;
&lt;p&gt;3.HTTP请求报文和响应报文：开始行 首部行 实体主体&lt;/p&gt;
&lt;p&gt;4.BOOTP和DHCP：Dynamic Host Configuration动态主机配置协议。需要IP地址的主机向DHCP服务器广播，源IP全0 目的主机IP全1，DHCP查找配置信息，若找到，返回，若找不到，从服务器IP地址池取一个地址分配给该计算机。&lt;/p&gt;
&lt;p&gt;5.SNMP 简单网络管理协议&lt;/p&gt;
&lt;p&gt;网络安全&lt;/p&gt;
&lt;p&gt;常规密钥密码体制：加密密钥和解密密钥是相同的密码体制，又称对称密钥体制。DES（Data Encryption Standard）和IDEA（International Data Encryption Algorithm）。&lt;/p&gt;
&lt;p&gt;公开密钥密码体制：为了解决常规密钥体制的密钥分配问题和对数字签名的需求。&lt;/p&gt;
&lt;p&gt;RSA公开密钥密码体制&lt;/p&gt;
&lt;p&gt;原理：根据数论，寻求两个大素数比较简单，而把两个大素数的乘积分解及其困难。&lt;/p&gt;
&lt;p&gt;数字签名：需要保证一下三点&lt;/p&gt;
&lt;p&gt;（1）接受者能够核实发送者对报文的签名 （2）发送者事后不能抵赖对报文的签名 （3）接收者不能伪造对报文的签名&lt;/p&gt;
&lt;p&gt;防火墙：是由软件硬件构成的系统，用来在两个网络之间实施接入控制策略。&lt;/p&gt;
&lt;p&gt;完，作者：Campanulaceae &lt;a href=&quot;http://weibo.com/u/1662536394&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;微博&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;To Be Continued…&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基本知识点&quot;&gt;&lt;a href=&quot;#基本知识点&quot; class=&quot;headerlink&quot; title=&quot;基本知识点&quot;&gt;&lt;/a&gt;基本知识点&lt;/h2&gt;&lt;p&gt;1.OSI参考模型（七层体系结构）&lt;/p&gt;
&lt;p&gt;物理层 - 数据链路层 - 网络层 - 运输层 - 会话层 - 表
    
    </summary>
    
      <category term="编织未来" scheme="https://lemonjing.github.io/categories/%E7%BC%96%E7%BB%87%E6%9C%AA%E6%9D%A5/"/>
    
    
      <category term="Note" scheme="https://lemonjing.github.io/tags/Note/"/>
    
      <category term="计算机网络" scheme="https://lemonjing.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>『原创』九种内部排序算法的Java实现及其性能测试</title>
    <link href="https://lemonjing.github.io/2016/02/22/7/"/>
    <id>https://lemonjing.github.io/2016/02/22/7/</id>
    <published>2016-02-22T11:45:27.000Z</published>
    <updated>2016-03-07T07:22:43.909Z</updated>
    
    <content type="html">&lt;p&gt;其中第九种为java.util.Arrays.sort（改进的快速排序方法）&lt;/p&gt;
&lt;p&gt;1. 100000的随机数据集&lt;br&gt;&lt;img src=&quot;http://7xlkoc.com1.z0.glb.clouddn.com/sort1.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;2. 200000的随机数据集&lt;br&gt;&lt;img src=&quot;http://7xlkoc.com1.z0.glb.clouddn.com/sort2.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;3. 500000的随机数据集&lt;br&gt;&lt;img src=&quot;http://7xlkoc.com1.z0.glb.clouddn.com/sort3.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;结论：归并排序和堆排序维持O(nlgn)的复杂度，速率差不多，表现优异。固定基准的快排表现很是优秀。而通过使用一个循环完成按增量分组后的直接插入的希尔排序，测试效果显著。冒泡，选择，直接插入都很慢，而冒泡效率是最低。&lt;/p&gt;
&lt;h2 id=&quot;1-插入排序-稳定&quot;&gt;&lt;a href=&quot;#1-插入排序-稳定&quot; class=&quot;headerlink&quot; title=&quot;1.插入排序[稳定]&quot;&gt;&lt;/a&gt;1.插入排序[稳定]&lt;/h2&gt;&lt;p&gt;适用于小数组,数组已排好序或接近于排好序速度将会非常快&lt;/p&gt;
&lt;p&gt;复杂度：O(n^2) - O(n) - O(n^2) - O(1)[平均 - 最好 - 最坏 - 空间复杂度]&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums&quot;&gt;
public void insertionSort(int[] a) {
        if (null == a || a.length &lt; 2) {
            return;
        }
        for (int i = 1; i &lt; a.length; i++) {
            // 暂存当前值
            int temp = a[i];
            int j = i - 1;
            while (j &gt;= 0 &amp;&amp; temp &lt; a[j]) {
                // 后移
                a[j + 1] = a[j];
                j--;
            }
            // 当前值归位
            a[j + 1] = temp;
        }
    }
&lt;/pre&gt;

&lt;h2 id=&quot;2-希尔排序-缩小增量排序-不稳定&quot;&gt;&lt;a href=&quot;#2-希尔排序-缩小增量排序-不稳定&quot; class=&quot;headerlink&quot; title=&quot;2.希尔排序(缩小增量排序)[不稳定]&quot;&gt;&lt;/a&gt;2.希尔排序(缩小增量排序)[不稳定]&lt;/h2&gt;&lt;p&gt;复杂度 小于O(n^2) 平均 O(nlgn) 最差O(n^s)，其中s大于1小于2 。空间复杂度O(1)&lt;/p&gt;
&lt;p&gt;内循环通过模拟并行的方式完成分组的内部直接插入排序，而不是一个一个分组分组的排，在10w的随机数据20w的随机数据均表现优异。&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums&quot;&gt;
public void shellSort(int[] a) {
        if (null == a || a.length &lt; 2) {
            return;
        }
        for (int d = a.length/2; d &gt; 0; d/=2) {
            // 从1B开始先和1A比较 然后2A与2B...然后再1C向前与同组的比较
            for (int i = d; i &lt; a.length; i++) {
                // 内部直接插入
                int temp = a[i];
                int j = i - d;
                while (j &gt;=0 &amp;&amp; temp &lt; a[j]) {
                    a[j+d] = a[j];
                    j -= d;
                }
                a[j+d] = temp;
            }
        }
    }
&lt;/pre&gt;

&lt;h2 id=&quot;3-冒泡排序-稳定&quot;&gt;&lt;a href=&quot;#3-冒泡排序-稳定&quot; class=&quot;headerlink&quot; title=&quot;3.冒泡排序[稳定]&quot;&gt;&lt;/a&gt;3.冒泡排序[稳定]&lt;/h2&gt;&lt;p&gt;复杂度：O(n^2) - O(n) - O(n^2) - O(1)[平均 - 最好 - 最坏 - 空间复杂度]&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums&quot;&gt;
public void bubbleSort(int[] a) {
        if (null == a || a.length &lt; 2) {
            return;
        }
        boolean flag;
        for (int i = 0; i &lt; a.length-1; i++) {
            flag = false;
            for (int j = 0; j &lt; a.length-1-i; j++) {
                if (a[j] &gt; a[j+1]) {
                    int temp = a[j];
                    a[j] = a[j+1];
                    a[j+1] = temp;
                    flag = true;
                }
            }
            if (false == flag) {
                return;
            }
        }
    }
&lt;/pre&gt;

&lt;h2 id=&quot;4-选择排序-不稳定&quot;&gt;&lt;a href=&quot;#4-选择排序-不稳定&quot; class=&quot;headerlink&quot; title=&quot;4.选择排序[不稳定]&quot;&gt;&lt;/a&gt;4.选择排序[不稳定]&lt;/h2&gt;&lt;p&gt;原理：每次从无序序列选取最小的&lt;/p&gt;
&lt;p&gt;复杂度：O(n^2) - O(n^2) - O(n^2) - O(1)[平均 - 最好 - 最坏 - 空间复杂度]&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums&quot;&gt;
public void selectSort(int[] a) {
        if (null == a || a.length &lt; 2) {
            return;
        }
        for (int i = 0; i &lt; a.length; i++) {
            int k = i;
            for (int j = i + 1; j &lt; a.length; j++) {
                if (a[j] &lt; a[k]) {
                    k = j;
                }
            }
            if (k!=i) {
                int temp = a[k];
                a[k] = a[i];
                a[i] = temp;
            }
        }
    }
&lt;/pre&gt;

&lt;h2 id=&quot;5-归并排序-稳定&quot;&gt;&lt;a href=&quot;#5-归并排序-稳定&quot; class=&quot;headerlink&quot; title=&quot;5.归并排序[稳定]&quot;&gt;&lt;/a&gt;5.归并排序[稳定]&lt;/h2&gt;&lt;p&gt;原理：采用分治法&lt;/p&gt;
&lt;p&gt;复杂度：O(nlogn) - O(nlgn) - O(nlgn) - O(n)[平均 - 最好 - 最坏 - 空间复杂度]&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums&quot;&gt;
// 排序
    public void mergeSort(int[] a, int low, int high) {
        if (null == a || a.length &lt; 2) {
            return;
        }
        int mid = (low + high) / 2;
        if (low &lt; high) {
            // 左边排序
            mergeSort(a, low, mid);
            // 右边排序
            mergeSort(a, mid + 1, high);
            // 有序序列合并
            merge(a, low, mid, high);
        }
    }

    // 合并
    private void merge(int a[], int low, int mid, int high) {
        // 临时数组
        int[] temp = new int[high - low + 1];
        // 左指针
        int i = low;
        // 右指针
        int j = mid + 1;
        // 临时数组索引
        int k = 0;

        while (i &lt;= mid=&quot;&quot; &amp;&amp;=&quot;&quot; j=&quot;&quot; &lt;=&quot;high)&quot; {=&quot;&quot; if=&quot;&quot; (a[i]=&quot;&quot; a[j])=&quot;&quot; temp[k++]=&quot;a[i++];&quot; }=&quot;&quot; else=&quot;&quot; 把左边剩余的数移入数组=&quot;&quot; while=&quot;&quot; (i=&quot;&quot; 把右边剩余的数移入数组=&quot;&quot; (j=&quot;&quot; 注意这里是low=&quot;&quot; +=&quot;&quot; t=&quot;&quot; for=&quot;&quot; (int=&quot;&quot; temp.length;=&quot;&quot; t++)=&quot;&quot; a[low=&quot;&quot; t]=&quot;temp[t];&quot; pre=&quot;&quot;&gt;

&lt;h2 id=&quot;6-快速排序-不稳定&quot;&gt;&lt;a href=&quot;#6-快速排序-不稳定&quot; class=&quot;headerlink&quot; title=&quot;6.快速排序[不稳定]&quot;&gt;&lt;/a&gt;6.快速排序[不稳定]&lt;/h2&gt;&lt;p&gt;原理：挖树填坑+分治&lt;/p&gt;
&lt;p&gt;复杂度：O(nlgn) - O(nlgn) - O(n^2) - O(1)[平均 - 最好 - 最坏 - 空间复杂度]&lt;/p&gt;
&lt;p&gt;栈空间0(lgn) - O(n)&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums&quot;&gt;
// 固定基准
public void quickSort(int[] a, int low, int high) {
        if (null == a || a.length &lt; 2) {
            return;
        }
        if (low &lt; high) {
            int mid = partition(a, low, high);
            quickSort(a, low, mid-1);
            quickSort(a, mid+1, high);
        }
    }

    private int partition(int[] a, int low, int high) {
        int pivot = a[low];

        while (low &lt; high) {
            // 注意等于，否则死循环
            while (low &lt; high &amp;&amp; a[high] &gt;= pivot) {
                high--;
            }
            a[low] = a[high];
            // 注意等于，否则死循环
            while (low &lt; high &amp;&amp; a[low] &lt;= pivot)=&quot;&quot; {=&quot;&quot; low++;=&quot;&quot; }=&quot;&quot; a[high]=&quot;a[low];&quot; a[low]=&quot;pivot;&quot; return=&quot;&quot; low;=&quot;&quot; &lt;=&quot;&quot; pre=&quot;&quot;&gt;

&lt;h2 id=&quot;7-堆排序-不稳定&quot;&gt;&lt;a href=&quot;#7-堆排序-不稳定&quot; class=&quot;headerlink&quot; title=&quot;7.堆排序[不稳定]&quot;&gt;&lt;/a&gt;7.堆排序[不稳定]&lt;/h2&gt;&lt;p&gt;堆一般指二叉堆。&lt;/p&gt;
&lt;p&gt;复杂度：O(nlogn) - O(nlgn) - O(nlgn) - O(1)[平均 - 最好 - 最坏 - 空间复杂度]&lt;/p&gt;
&lt;p&gt;大顶堆实现从小到大的升序排列，小顶堆一般用于构造优先队列&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums&quot;&gt;
public void heapSort(int[] a) {
        if (null == a || a.length &lt; 2) {
            return;
        }

        buildMaxHeap(a);

        for (int i = a.length - 1; i &gt;= 0; i--) {
            int temp = a[0];
            a[0] = a[i];
            a[i] = temp;

            adjustHeap(a, i, 0);
        }
    }

    // 建堆
    private void buildMaxHeap(int[] a) {
        int mid = a.length / 2;
        for (int i = mid; i &gt;= 0; i--) {
            adjustHeap(a, a.length, i);
        }
    }

    // 递归调整堆
    private void adjustHeap(int[] a, int size, int parent) {
        int left = 2 * parent + 1;
        int right = 2 * parent + 2;

        int largest = parent;
        if (left &lt; size &amp;&amp; a[left] &gt; a[parent]) {
            largest = left;
        }

        if (right &lt; size &amp;&amp; a[right] &gt; a[largest]) {
            largest = right;
        }

        if (parent != largest) {
            int temp = a[parent];
            a[parent] = a[largest];
            a[largest] = temp;
            adjustHeap(a, size, largest);
        }
    }
&lt;/pre&gt;

&lt;h2 id=&quot;8-基数排序-稳定&quot;&gt;&lt;a href=&quot;#8-基数排序-稳定&quot; class=&quot;headerlink&quot; title=&quot;8.基数排序[稳定]&quot;&gt;&lt;/a&gt;8.基数排序[稳定]&lt;/h2&gt;&lt;p&gt;原理：分配加收集&lt;/p&gt;
&lt;p&gt;复杂度： O(d(n+r)) r为基数d为位数 空间复杂度O(n+r)&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums&quot;&gt;
// 基数排序
    public void radixSort(int[] a, int begin, int end, int digit) {
        // 基数
        final int radix = 10;
        // 桶中的数据统计
        int[] count = new int[radix];
        int[] bucket = new int[end-begin+1];

        // 按照从低位到高位的顺序执行排序过程
        for (int i = 1; i &lt;= digit;=&quot;&quot; i++)=&quot;&quot; {=&quot;&quot; 清空桶中的数据统计=&quot;&quot; for=&quot;&quot; (int=&quot;&quot; j=&quot;0;&quot; &lt;=&quot;&quot; radix;=&quot;&quot; j++)=&quot;&quot; count[j]=&quot;0;&quot; }=&quot;&quot; 统计各个桶将要装入的数据个数=&quot;&quot; int=&quot;&quot; index=&quot;getDigit(a[j],&quot; i);=&quot;&quot; count[index]++;=&quot;&quot; count[i]表示第i个桶的右边界索引=&quot;&quot; +=&quot;&quot; count[j=&quot;&quot; -=&quot;&quot; 1];=&quot;&quot; 将数据依次装入桶中=&quot;&quot; 这里要从右向左扫描，保证排序稳定性=&quot;&quot;&gt;= begin; j--) {
                int index = getDigit(a[j], i);
                bucket[count[index] - 1] = a[j];
                count[index]--;
            }

            // 取出，此时已是对应当前位数有序的表
            for (int j = 0; j &lt; bucket.length; j++) {
                a[j] = bucket[j];
            }
        }
    }

    // 获取x的第d位的数字，其中最低位d=1
    private int getDigit(int x, int d) {
        String div = &quot;1&quot;;
        while (d &gt;= 2) {
            div += &quot;0&quot;;
            d--;
        }
        return x/Integer.parseInt(div) % 10;
    }
}
&lt;/=&gt;&lt;/pre&gt;

&lt;p&gt;排序代码地址 &lt;a href=&quot;https://github.com/Lemonjing/TinyCoding/tree/master/src/main/java/com/tinymood/javase/sort&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/Lemonjing/TinyCoding/tree/master/src/main/java/com/tinymood/javase/sort&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;性能测试代码地址 &lt;a href=&quot;https://github.com/Lemonjing/TinyCoding/tree/master/src/test/java/com/tinymood/javase/sort&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/Lemonjing/TinyCoding/tree/master/src/test/java/com/tinymood/javase/sort&lt;/a&gt;&lt;/p&gt;
&lt;/=&gt;&lt;/pre&gt;&lt;/=&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;其中第九种为java.util.Arrays.sort（改进的快速排序方法）&lt;/p&gt;
&lt;p&gt;1. 100000的随机数据集&lt;br&gt;&lt;img src=&quot;http://7xlkoc.com1.z0.glb.clouddn.com/sort1.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;2.
    
    </summary>
    
      <category term="算法" scheme="https://lemonjing.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="编织未来" scheme="https://lemonjing.github.io/categories/%E7%AE%97%E6%B3%95/%E7%BC%96%E7%BB%87%E6%9C%AA%E6%9D%A5/"/>
    
    
      <category term="Java" scheme="https://lemonjing.github.io/tags/Java/"/>
    
      <category term="排序" scheme="https://lemonjing.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出类装载器ClassLoader</title>
    <link href="https://lemonjing.github.io/2016/02/19/65/"/>
    <id>https://lemonjing.github.io/2016/02/19/65/</id>
    <published>2016-02-19T12:50:01.000Z</published>
    <updated>2016-03-07T07:22:43.910Z</updated>
    
    <content type="html">&lt;h2 id=&quot;类装载器工作机制&quot;&gt;&lt;a href=&quot;#类装载器工作机制&quot; class=&quot;headerlink&quot; title=&quot;类装载器工作机制&quot;&gt;&lt;/a&gt;类装载器工作机制&lt;/h2&gt;&lt;p&gt;类装载器就是寻找类的节码文件并构造出类在JVM内部表示对象的组件。在Java中，类装载器把一个类装入JVM中，要经过以下步骤： &lt;/p&gt;
&lt;p&gt;[1.] &lt;strong&gt;装载&lt;/strong&gt;：查找和导入Class文件；&lt;br&gt;[2.] &lt;strong&gt;链接&lt;/strong&gt;：执行校验、准备和解析步骤，其中解析步骤是可以选择的：&lt;br&gt;    [2.1] 校验：检查载入Class文件数据的正确性；&lt;br&gt;    [2.2] 准备：给类的静态变量分配存储空间；&lt;br&gt;    [2.3] 解析：将符号引用转成直接引用；&lt;br&gt;[3.] &lt;strong&gt;初始化&lt;/strong&gt;：对类的静态变量、静态代码块执行初始化工作。 &lt;/p&gt;
&lt;p&gt;类装载工作由ClassLoader及其子类负责，ClassLoader是一个重要的Java运行时系统组件，它负责在运行时查找和装入Class字节码文件。JVM在运行时会产生三个ClassLoader：&lt;strong&gt;根装载器&lt;/strong&gt;、ExtClassLoader（&lt;strong&gt;扩展类装载器&lt;/strong&gt;）和AppClassLoader（&lt;strong&gt;系统类装载器&lt;/strong&gt;）。其中，根装载器不是ClassLoader的子类，它使用C++编写，因此我们在Java中看不到它，根装载器负责装载JRE的核心类库，如JRE目标下的rt.jar、charsets.jar等。ExtClassLoader和AppClassLoader都是ClassLoader的子类。其中ExtClassLoader负责装载JRE扩展目录ext中的JAR类包；AppClassLoader负责装载Classpath路径下的类包。 &lt;/p&gt;
&lt;p&gt;这三个类装载器之间存在父子层级关系，即根装载器是ExtClassLoader的父装载器，ExtClassLoader是AppClassLoader的父装载器。默认情况下，使用AppClassLoader装载应用程序的类，我们可以做一个实验： &lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums&quot;&gt;
public class ClassLoaderTest {
    public static void main(String[] args) {
        ClassLoader loader = Thread.currentThread().getContextClassLoader();
        System.out.println(&quot;current loader:&quot;+loader);
        System.out.println(&quot;parent loader:&quot;+loader.getParent());
        System.out.println(&quot;grandparent loader:&quot;+loader.getParent(). getParent());
    }
}
&lt;/pre&gt;

&lt;p&gt;运行以上代码，在控制台上将打出以下信息： &lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums&quot;&gt;
current loader:sun.misc.Launcher$AppClassLoader@131f71a 
parent loader:sun.misc.Launcher$ExtClassLoader@15601ea 
//①根装载器在Java中访问不到，所以返回null 
grandparent loader:null
&lt;/pre&gt;

&lt;p&gt;通过以上的输出信息，我们知道当前的ClassLoader是AppClassLoader，父ClassLoader是ExtClassLoader，祖父ClassLoader是根类装载器，因为在Java中无法获得它的句柄，所以仅返回null。 &lt;/p&gt;
&lt;p&gt;JVM装载类时使用“全盘负责双亲委托机制”，“全盘负责”是指当一个ClassLoader装载一个类的时，除非显式地使用另一个ClassLoader，该类所依赖及引用的类也由这个ClassLoader载入；“双亲委托机制”是指先委托父装载器寻找目标类，只有在找不到的情况下才从自己的类路径中查找并装载目标类。这一点是从安全角度考虑的，试想如果有人编写了一个恶意的基础类（如java.lang.String）并装载到JVM中将会引起多么可怕的后果。但是由于有了“全盘负责委托机制”，java.lang.String永远是由根装载器来装载的，这样就避免了上述事件的发生。 &lt;/p&gt;
&lt;h2 id=&quot;ClassLoader重要方法&quot;&gt;&lt;a href=&quot;#ClassLoader重要方法&quot; class=&quot;headerlink&quot; title=&quot;ClassLoader重要方法&quot;&gt;&lt;/a&gt;ClassLoader重要方法&lt;/h2&gt;&lt;p&gt;在Java中，ClassLoader是一个抽象类，位于java.lang包中。下面对该类的一些重要接口方法进行介绍： &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Class loadClass(String name)&lt;/strong&gt;&lt;br&gt;name参数指定类装载器需要装载类的名字，必须使用全限定类名，如com.baobaotao. beans.Car。该方法有一个重载方法loadClass(String name ,boolean resolve)，resolve参数告诉类装载器是否需要解析该类。在初始化类之前，应考虑进行类解析的工作，但并不是所有的类都需要解析，如果JVM只需要知道该类是否存在或找出该类的超类，那么就不需要进行解析。 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Class defineClass(String name, byte[] b, int off, int len)&lt;/strong&gt;&lt;br&gt;将类文件的字节数组转换成JVM内部的java.lang.Class对象。字节数组可以从本地文件系统、远程网络获取。name为字节数组对应的全限定类名。 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Class findSystemClass(String name)&lt;/strong&gt;&lt;br&gt;   从本地文件系统载入Class文件，如果本地文件系统不存在该Class文件，将抛出ClassNotFoundException异常。该方法是JVM默认使用的装载机制。 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Class findLoadedClass(String name)&lt;/strong&gt;&lt;br&gt;  调用该方法来查看ClassLoader是否已装入某个类。如果已装入，那么返回java.lang.Class对象，否则返回null。如果强行装载已存在的类，将会抛出链接错误。 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ClassLoader getParent()&lt;/strong&gt;&lt;br&gt;   获取类装载器的父装载器，除根装载器外，所有的类装载器都有且仅有一个父装载器，ExtClassLoader的父装载器是根装载器，因为根装载器非Java编写，所以无法获得，将返回null。 &lt;/p&gt;
&lt;p&gt;除JVM默认的三个ClassLoader以外，可以编写自己的第三方类装载器，以实现一些特殊的需求。类文件被装载并解析后，在JVM内将拥有一个对应的java.lang.Class类描述对象，该类的实例都拥有指向这个类描述对象的引用，而类描述对象又拥有指向关联ClassLoader的引用，如图所示。&lt;br&gt;&lt;a href=&quot;http://www.tinymood.com/wp-content/uploads/2016/02/201602191302195.png&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;http://www.tinymood.com/wp-content/uploads/2016/02/201602191302195.png&quot; alt=&quot;6874747&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;每一个类在JVM中都拥有一个对应的java.lang.Class对象，它提供了类结构信息的描述。数组、枚举、注解以及基本Java类型（如int、double等），甚至void都拥有对应的Class对象。Class没有public的构造方法。Class对象是在装载类时由JVM通过调用类装载器中的defineClass()方法自动构造的。 &lt;/p&gt;
&lt;h2 id=&quot;类的初始化&quot;&gt;&lt;a href=&quot;#类的初始化&quot; class=&quot;headerlink&quot; title=&quot;类的初始化&quot;&gt;&lt;/a&gt;类的初始化&lt;/h2&gt;&lt;p&gt; 类什么时候才被初始化：&lt;br&gt;1）创建类的实例，也就是new一个对象&lt;br&gt;2）访问某个类或接口的静态变量，或者对该静态变量赋值&lt;br&gt;3）调用类的静态方法&lt;br&gt;4）反射（Class.forName(“com.lyj.load”)）&lt;br&gt;5）初始化一个类的子类（会首先初始化子类的父类）&lt;br&gt;6）JVM启动时标明的启动类，即文件名和类名相同的那个类&lt;/p&gt;
&lt;p&gt;只有这6中情况才会导致类的类的初始化。&lt;br&gt;类的初始化步骤：&lt;br&gt;1. 如果这个类还没有被加载和链接，那先进行加载和链接&lt;br&gt;2. 假如这个类存在直接父类，并且这个类还没有被初始化（注意：在一个类加载器中，类只能初始化一次），那就初始化直接的父类（不适用于接口）&lt;br&gt;3. 加入类中存在初始化语句（如static变量和static块），那就依次执行这些初始化语句。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;类装载器工作机制&quot;&gt;&lt;a href=&quot;#类装载器工作机制&quot; class=&quot;headerlink&quot; title=&quot;类装载器工作机制&quot;&gt;&lt;/a&gt;类装载器工作机制&lt;/h2&gt;&lt;p&gt;类装载器就是寻找类的节码文件并构造出类在JVM内部表示对象的组件。在Java中，类装载器把一
    
    </summary>
    
      <category term="编织未来" scheme="https://lemonjing.github.io/categories/%E7%BC%96%E7%BB%87%E6%9C%AA%E6%9D%A5/"/>
    
    
      <category term="Java" scheme="https://lemonjing.github.io/tags/Java/"/>
    
      <category term="类加载器" scheme="https://lemonjing.github.io/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出Java泛型</title>
    <link href="https://lemonjing.github.io/2016/02/19/67/"/>
    <id>https://lemonjing.github.io/2016/02/19/67/</id>
    <published>2016-02-19T05:16:37.000Z</published>
    <updated>2016-03-07T07:22:43.909Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;http://7xlkoc.com1.z0.glb.clouddn.com/java2.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;泛型概念的提出（为什么需要泛型）？&quot;&gt;&lt;a href=&quot;#泛型概念的提出（为什么需要泛型）？&quot; class=&quot;headerlink&quot; title=&quot;泛型概念的提出（为什么需要泛型）？&quot;&gt;&lt;/a&gt;泛型概念的提出（为什么需要泛型）？&lt;/h2&gt;&lt;p&gt;首先，我们看下下面这段简短的代码:&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums&quot;&gt;
public class GenericTest {

    public static void main(String[] args) {
        List list = new ArrayList();
        list.add(&quot;qqyumidi&quot;);
        list.add(&quot;corn&quot;);
        list.add(100);

        for (int i = 0; i &lt; list.size(); i++) {
            String name = (String) list.get(i); // 1
            System.out.println(&quot;name:&quot; + name);
        }
    }
}
&lt;/pre&gt;

&lt;p&gt;定义了一个List类型的集合，先向其中加入了两个字符串类型的值，随后加入一个Integer类型的值。这是完全允许的，因为此时list默认的类型为Object类型。在之后的循环中，由于忘记了之前在list中也加入了Integer类型的值或其他编码原因，很容易出现类似于//1中的错误。因为编译阶段正常，而运行时会出现“java.lang.ClassCastException”异常。因此，导致此类错误编码过程中不易发现。&lt;/p&gt;
&lt;p&gt; 在如上的编码过程中，我们发现主要存在两个问题：&lt;/p&gt;
&lt;p&gt;1.当我们将一个对象放入集合中，集合不会记住此对象的类型，当再次从集合中取出此对象时，改对象的编译类型变成了Object类型，但其运行时类型任然为其本身类型。&lt;/p&gt;
&lt;p&gt;2.因此，//1处取出集合元素时需要人为的强制类型转化到具体的目标类型，且很容易出现“java.lang.ClassCastException”异常。&lt;/p&gt;
&lt;p&gt;那么有没有什么办法可以使集合能够记住集合内元素各类型，且能够达到只要编译时不出现问题，运行时就不会出现“java.lang.ClassCastException”异常呢？答案就是使用泛型。&lt;/p&gt;
&lt;h2 id=&quot;什么是泛型？&quot;&gt;&lt;a href=&quot;#什么是泛型？&quot; class=&quot;headerlink&quot; title=&quot;什么是泛型？&quot;&gt;&lt;/a&gt;什么是泛型？&lt;/h2&gt;&lt;p&gt;泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。&lt;/p&gt;
&lt;p&gt;看着好像有点复杂，首先我们看下上面那个例子采用泛型的写法。&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums&quot;&gt;
public class GenericTest {

    public static void main(String[] args) {
        /*
        List list = new ArrayList();
        list.add(&quot;qqyumidi&quot;);
        list.add(&quot;corn&quot;);
        list.add(100);
        */

        List&lt;string&gt; list = new ArrayList&lt;string&gt;();
        list.add(&quot;qqyumidi&quot;);
        list.add(&quot;corn&quot;);
        //list.add(100);   // 1  提示编译错误

        for (int i = 0; i &lt; list.size(); i++) {
            String name = list.get(i); // 2
            System.out.println(&quot;name:&quot; + name);
        }
    }
}
&lt;/string&gt;&lt;/string&gt;&lt;/pre&gt;

&lt;p&gt;采用泛型写法后，在//1处想加入一个Integer类型的对象时会出现编译错误，通过List&lt;string&gt;，直接限定了list集合中只能含有String类型的元素，从而在//2处无须进行强制类型转换，因为此时，集合能够记住元素的类型信息，编译器已经能够确认它是String类型了。&lt;/string&gt;&lt;/p&gt;
&lt;p&gt;结合上面的泛型定义，我们知道在List&lt;string&gt;中，String是类型实参，也就是说，相应的List接口中肯定含有类型形参。且get()方法的返回结果也直接是此形参类型（也就是对应的传入的类型实参）。下面就来看看List接口的的具体定义：&lt;/string&gt;&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums&quot;&gt;
public interface List&lt;e&gt; extends Collection&lt;e&gt; {

    int size();

    boolean isEmpty();

    boolean contains(Object o);

    Iterator&lt;e&gt; iterator();

    Object[] toArray();

    &lt;t&gt; T[] toArray(T[] a);

    boolean add(E e);

    boolean remove(Object o);

    boolean containsAll(Collection&lt;?&gt; c);

    boolean addAll(Collection&lt;? extends E&gt; c);

    boolean addAll(int index, Collection&lt;? extends E&gt; c);

    boolean removeAll(Collection&lt;?&gt; c);

    boolean retainAll(Collection&lt;?&gt; c);

    void clear();

    boolean equals(Object o);

    int hashCode();

    E get(int index);

    E set(int index, E element);

    void add(int index, E element);

    E remove(int index);

    int indexOf(Object o);

    int lastIndexOf(Object o);

    ListIterator&lt;e&gt; listIterator();

    ListIterator&lt;e&gt; listIterator(int index);

    List&lt;e&gt; subList(int fromIndex, int toIndex);
}
&lt;/e&gt;&lt;/e&gt;&lt;/e&gt;&lt;/t&gt;&lt;/e&gt;&lt;/e&gt;&lt;/e&gt;&lt;/pre&gt;

&lt;p&gt;我们可以看到，在List接口中采用泛型化定义之后，&lt;e&gt;中的E表示类型形参，可以接收具体的类型实参，并且此接口定义中，凡是出现E的地方均表示相同的接受自外部的类型实参。&lt;br&gt;自然的，ArrayList作为List接口的实现类，其定义形式是：&lt;/e&gt;&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums&quot;&gt;
public class ArrayList&lt;e&gt; extends AbstractList&lt;e&gt; 
        implements List&lt;e&gt;, RandomAccess, Cloneable, java.io.Serializable {

    public boolean add(E e) {
        ensureCapacityInternal(size + 1);  // Increments modCount!!
        elementData[size++] = e;
        return true;
    }

    public E get(int index) {
        rangeCheck(index);
        checkForComodification();
        return ArrayList.this.elementData(offset + index);
    }

    //...省略掉其他具体的定义过程

}
&lt;/e&gt;&lt;/e&gt;&lt;/e&gt;&lt;/pre&gt;

&lt;p&gt;由此，我们从源代码角度明白了为什么//1处加入Integer类型对象编译错误，且//2处get()到的类型直接就是String类型了。&lt;/p&gt;
&lt;h2 id=&quot;自定义泛型接口、泛型类和泛型方法&quot;&gt;&lt;a href=&quot;#自定义泛型接口、泛型类和泛型方法&quot; class=&quot;headerlink&quot; title=&quot;自定义泛型接口、泛型类和泛型方法&quot;&gt;&lt;/a&gt;自定义泛型接口、泛型类和泛型方法&lt;/h2&gt;&lt;p&gt;从上面的内容中，大家已经明白了泛型的具体运作过程。也知道了接口、类和方法也都可以使用泛型去定义，以及相应的使用。是的，在具体使用时，可以分为泛型接口、泛型类和泛型方法。&lt;/p&gt;
&lt;p&gt;自定义泛型接口、泛型类和泛型方法与上述Java源码中的List、ArrayList类似。如下，我们看一个最简单的泛型类和方法定义：&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums&quot;&gt;
public class GenericTest {

    public static void main(String[] args) {

        Box&lt;string&gt; name = new Box&lt;string&gt;(&quot;corn&quot;);
        System.out.println(&quot;name:&quot; + name.getData());
    }

}

class Box&lt;t&gt; {

    private T data;

    public Box() {

    }

    public Box(T data) {
        this.data = data;
    }

    public T getData() {
        return data;
    }

}
&lt;/t&gt;&lt;/string&gt;&lt;/string&gt;&lt;/pre&gt;

&lt;p&gt;在泛型接口、泛型类和泛型方法的定义过程中，我们常见的如T、E、K、V等形式的参数常用于表示泛型形参，由于接收来自外部使用时候传入的类型实参。那么对于不同传入的类型实参，生成的相应对象实例的类型是不是一样的呢？&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums&quot;&gt;
public class GenericTest {

    public static void main(String[] args) {

        Box&lt;string&gt; name = new Box&lt;string&gt;(&quot;corn&quot;);
        Box&lt;integer&gt; age = new Box&lt;integer&gt;(712);

        System.out.println(&quot;name class:&quot; + name.getClass());      // com.qqyumidi.Box
        System.out.println(&quot;age class:&quot; + age.getClass());        // com.qqyumidi.Box
        System.out.println(name.getClass() == age.getClass());    // true

    }

}
&lt;/integer&gt;&lt;/integer&gt;&lt;/string&gt;&lt;/string&gt;&lt;/pre&gt;

&lt;p&gt;由此，我们发现，在使用泛型类时，虽然传入了不同的泛型实参，但并没有真正意义上生成不同的类型，传入不同泛型实参的泛型类在内存上只有一个，即还是原来的最基本的类型（本实例中为Box），当然，在逻辑上我们可以理解成多个不同的泛型类型。&lt;/p&gt;
&lt;p&gt;究其原因，在于Java中的泛型这一概念提出的目的，导致其只是作用于代码编译阶段，在编译过程中，对于正确检验泛型结果后，会将泛型的相关信息擦出，也就是说，成功编译过后的class文件中是不包含任何泛型信息的。泛型信息不会进入到运行时阶段。&lt;/p&gt;
&lt;p&gt;对此总结成一句话：泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。&lt;/p&gt;
&lt;h2 id=&quot;类型通配符&quot;&gt;&lt;a href=&quot;#类型通配符&quot; class=&quot;headerlink&quot; title=&quot;类型通配符&quot;&gt;&lt;/a&gt;类型通配符&lt;/h2&gt;&lt;p&gt;接着上面的结论，我们知道，Box&lt;number&gt;和Box&lt;integer&gt;实际上都是Box类型，现在需要继续探讨一个问题，那么在逻辑上，类似于Box&lt;number&gt;和Box&lt;integer&gt;是否可以看成具有父子关系的泛型类型呢？&lt;/integer&gt;&lt;/number&gt;&lt;/integer&gt;&lt;/number&gt;&lt;/p&gt;
&lt;p&gt;为了弄清这个问题，我们继续看下下面这个例子:&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums&quot;&gt;
public class GenericTest {

    public static void main(String[] args) {

        Box&lt;number&gt; name = new Box&lt;number&gt;(99);
        Box&lt;integer&gt; age = new Box&lt;integer&gt;(712);

        getData(name);

        //The method getData(Box&lt;number&gt;) in the type GenericTest is 
        //not applicable for the arguments (Box&lt;integer&gt;)
        getData(age);   // 1

    }

    public static void getData(Box&lt;number&gt; data){
        System.out.println(&quot;data :&quot; + data.getData());
    }

}
&lt;/number&gt;&lt;/integer&gt;&lt;/number&gt;&lt;/integer&gt;&lt;/integer&gt;&lt;/number&gt;&lt;/number&gt;&lt;/pre&gt;

&lt;p&gt;我们发现，在代码//1处出现了错误提示信息：The method getData(Box&lt;number&gt;) in the t ype GenericTest is not applicable for the arguments (Box&lt;integer&gt;)。显然，通过提示信息，我们知道Box&lt;number&gt;在逻辑上不能视为Box&lt;integer&gt;的父类。那么，原因何在呢？&lt;/integer&gt;&lt;/number&gt;&lt;/integer&gt;&lt;/number&gt;&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums&quot;&gt;
public class GenericTest {

    public static void main(String[] args) {

        Box&lt;integer&gt; a = new Box&lt;integer&gt;(712);
        Box&lt;number&gt; b = a;  // 1
        Box&lt;float&gt; f = new Box&lt;float&gt;(3.14f);
        b.setData(f);        // 2

    }

    public static void getData(Box&lt;number&gt; data) {
        System.out.println(&quot;data :&quot; + data.getData());
    }

}

class Box&lt;t&gt; {

    private T data;

    public Box() {

    }

    public Box(T data) {
        setData(data);
    }

    public T getData() {
        return data;
    }

    public void setData(T data) {
        this.data = data;
    }

}
&lt;/t&gt;&lt;/number&gt;&lt;/float&gt;&lt;/float&gt;&lt;/number&gt;&lt;/integer&gt;&lt;/integer&gt;&lt;/pre&gt;

&lt;p&gt;这个例子中，显然//1和//2处肯定会出现错误提示的。在此我们可以使用反证法来进行说明。&lt;/p&gt;
&lt;p&gt;假设Box&lt;number&gt;在逻辑上可以视为Box&lt;integer&gt;的父类，那么//1和//2处将不会有错误提示了，那么问题就出来了，通过getData()方法取出数据时到底是什么类型呢？Integer? Float? 还是Number？且由于在编程过程中的顺序不可控性，导致在必要的时候必须要进行类型判断，且进行强制类型转换。显然，这与泛型的理念矛盾，因此，在逻辑上Box&lt;number&gt;不能视为Box&lt;integer&gt;的父类。&lt;/integer&gt;&lt;/number&gt;&lt;/integer&gt;&lt;/number&gt;&lt;/p&gt;
&lt;p&gt;好，那我们回过头来继续看“类型通配符”中的第一个例子，我们知道其具体的错误提示的深层次原因了。那么如何解决呢？总部能再定义一个新的函数吧。这和Java中的多态理念显然是违背的，因此，我们需要一个在逻辑上可以用来表示同时是Box&lt;integer&gt;和Box&lt;number&gt;的父类的一个引用类型，由此，类型通配符应运而生。&lt;/number&gt;&lt;/integer&gt;&lt;/p&gt;
&lt;p&gt;类型通配符一般是使用 ? 代替具体的类型实参。注意了，此处是类型实参，而不是类型形参！且Box&amp;lt;?&amp;gt;在逻辑上是Box&lt;integer&gt;、Box&lt;number&gt;…等所有Box&amp;lt;具体类型实参&amp;gt;的父类。由此，我们依然可以定义泛型方法，来完成此类需求。&lt;/number&gt;&lt;/integer&gt;&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums&quot;&gt;
public class GenericTest {

    public static void main(String[] args) {

        Box&lt;string&gt; name = new Box&lt;string&gt;(&quot;corn&quot;);
        Box&lt;integer&gt; age = new Box&lt;integer&gt;(712);
        Box&lt;number&gt; number = new Box&lt;number&gt;(314);

        getData(name);
        getData(age);
        getData(number);
    }

    public static void getData(Box&lt;?&gt; data) {
        System.out.println(&quot;data :&quot; + data.getData());
    }

}
&lt;/number&gt;&lt;/number&gt;&lt;/integer&gt;&lt;/integer&gt;&lt;/string&gt;&lt;/string&gt;&lt;/pre&gt;

&lt;p&gt;有时候，我们还可能听到类型通配符上限和类型通配符下限。具体有是怎么样的呢？&lt;/p&gt;
&lt;p&gt;在上面的例子中，如果需要定义一个功能类似于getData()的方法，但对类型实参又有进一步的限制：只能是Number类及其子类。此时，需要用到类型通配符上限。&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums&quot;&gt;
public class GenericTest {

    public static void main(String[] args) {

        Box&lt;string&gt; name = new Box&lt;string&gt;(&quot;corn&quot;);
        Box&lt;integer&gt; age = new Box&lt;integer&gt;(712);
        Box&lt;number&gt; number = new Box&lt;number&gt;(314);

        getData(name);
        getData(age);
        getData(number);

        //getUpperNumberData(name); // 1
        getUpperNumberData(age);    // 2
        getUpperNumberData(number); // 3
    }

    public static void getData(Box&lt;?&gt; data) {
        System.out.println(&quot;data :&quot; + data.getData());
    }

    public static void getUpperNumberData(Box&lt;? extends Number&gt; data){
        System.out.println(&quot;data :&quot; + data.getData());
    }

}
&lt;/number&gt;&lt;/number&gt;&lt;/integer&gt;&lt;/integer&gt;&lt;/string&gt;&lt;/string&gt;&lt;/pre&gt;

&lt;p&gt;此时，显然，在代码//1处调用将出现错误提示，而//2 //3处调用正常。&lt;/p&gt;
&lt;p&gt;类型通配符上限通过形如Box&amp;lt;? extends Number&amp;gt;形式定义，相对应的，类型通配符下限为Box&amp;lt;? super Number&amp;gt;形式，其含义与类型通配符上限正好相反，在此不作过多阐述了。&lt;/p&gt;
&lt;h2 id=&quot;话外篇&quot;&gt;&lt;a href=&quot;#话外篇&quot; class=&quot;headerlink&quot; title=&quot;话外篇&quot;&gt;&lt;/a&gt;话外篇&lt;/h2&gt;&lt;p&gt;本文中的例子主要是为了阐述泛型中的一些思想而简单举出的，并不一定有着实际的可用性。另外，一提到泛型，相信大家用到最多的就是在集合中，其实，在实际的编程过程中，自己可以使用泛型去简化开发，且能很好的保证代码质量。并且还要注意的一点是，Java中没有所谓的泛型数组一说。&lt;/p&gt;
&lt;p&gt;对于泛型，最主要的还是需要理解其背后的思想和目的。&lt;/p&gt;
&lt;p&gt;注：本文转载于 &lt;a href=&quot;http://www.cnblogs.com/lwbqqyumidi/p/3837629.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/lwbqqyumidi/p/3837629.html&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xlkoc.com1.z0.glb.clouddn.com/java2.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;泛型概念的提出（为什么需要泛型）？&quot;&gt;&lt;a href=&quot;#泛型概念的提出（为什么需要泛型）？&quot; class=&quot;hea
    
    </summary>
    
      <category term="编织未来" scheme="https://lemonjing.github.io/categories/%E7%BC%96%E7%BB%87%E6%9C%AA%E6%9D%A5/"/>
    
    
      <category term="Java" scheme="https://lemonjing.github.io/tags/Java/"/>
    
      <category term="generic" scheme="https://lemonjing.github.io/tags/generic/"/>
    
      <category term="泛型" scheme="https://lemonjing.github.io/tags/%E6%B3%9B%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出IOC概念</title>
    <link href="https://lemonjing.github.io/2016/02/19/66/"/>
    <id>https://lemonjing.github.io/2016/02/19/66/</id>
    <published>2016-02-19T03:52:14.000Z</published>
    <updated>2016-03-07T07:22:43.908Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;http://www.tinymood.com/wp-content/uploads/2016/02/2016021903563940.png&quot; alt=&quot;HLyJOSv&quot;&gt;&lt;br&gt;&lt;strong&gt;什么是IOC？&lt;/strong&gt;&lt;br&gt;IoC(Inversion of Control)，意为控制反转，不是什么技术，而是一种设计思想。Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。&lt;/p&gt;
&lt;p&gt;如何理解好Ioc呢？理解好Ioc的关键是要明确“谁控制谁，控制什么，为何是反转（有反转就应该有正转了），哪些方面反转了”，那我们来深入分析一下：&lt;/p&gt;
&lt;p&gt;•谁控制谁，控制什么：传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对 象的创建；谁控制谁？当然是IoC 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。&lt;/p&gt;
&lt;p&gt;•为何是反转，哪些方面反转了：有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。&lt;/p&gt;
&lt;p&gt;下面举个例子说明说明是IOC：&lt;/p&gt;
&lt;p&gt;假设我们要设计一个Girl和一个Boy类，其中Girl有kiss方法，即Girl想要Kiss一个Boy。那么，我们的问题是，Girl如何能够认识这个Boy？&lt;/p&gt;
&lt;p&gt;在我们中国，常见的ＭＭ与GG的认识方式有以下几种:&lt;br&gt;1.青梅竹马&lt;br&gt;2.亲友介绍&lt;br&gt;3.父母包办&lt;/p&gt;
&lt;p&gt;那么哪一种才是最好呢？ 　　&lt;br&gt;1. 青梅竹马：Girl从小就知道自己的Boy。&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums&quot;&gt;
public class Girl {　
    void kiss(){ 
　　　 Boy boy = new Boy(); 
　　} 
} 
&lt;/pre&gt;

&lt;p&gt;然而从开始就创建的Boy缺点就是无法在更换。并且要负责Boy的整个生命周期。如果我们的Girl想要换一个怎么办？（笔者严重不支持Girl经常更换Boy）&lt;br&gt;2.亲友介绍：由中间人负责提供Boy来见面&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;prettyprint linenums&quot;&gt;&lt;br&gt;public class Girl {&lt;br&gt;　 void kiss(){&lt;br&gt;　　　 Boy boy = BoyFactory.createBoy();　　　&lt;br&gt;　 }&lt;br&gt;}&lt;br&gt;&lt;/pre&gt;&lt;br&gt;亲友介绍，固然是好。如果不满意，尽管另外换一个好了。但是，亲友BoyFactory经常是以Singleton的形式出现，不然就是，存在于Globals，无处不在，无处不能。实在是太繁琐了一点，不够灵活。我为什么一定要这个亲友掺和进来呢？为什么一定要付给她介绍费呢？万一最好的朋友爱上了我的男朋友呢？&lt;br&gt;3.父母包办：一切交给父母，自己不用费吹灰之力，只需要等着Kiss就好了。&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;prettyprint linenums&quot;&gt;&lt;br&gt;public class Girl {&lt;br&gt;　  void kiss(Boy boy){&lt;br&gt;　　　 // kiss boy　&lt;br&gt;　　　boy.kiss();&lt;br&gt;　　}&lt;br&gt;}&lt;br&gt;&lt;/pre&gt;&lt;br&gt;Well，这是对Girl最好的方法，只要想办法贿赂了Girl的父母，并把Boy交给他。那么我们就可以轻松的和Girl来Kiss了。看来几千年传统的父母之命还真是有用哦。至少Boy和Girl不用自己瞎忙乎了。 &lt;/p&gt;
&lt;p&gt;这就是IOC，将对象的创建和获取提取到外部。由外部容器提供需要的组件。 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IoC能做什么&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;IoC 不是一种技术，只是一种思想，一个重要的面向对象编程的法则，它能指导我们如何设计出松耦合、更优良的程序。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了IoC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是 松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。&lt;/p&gt;
&lt;p&gt;其实IoC对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在IoC/DI思想中，应用程序就变成被动的了，被动的等待IoC容器来创建并注入它所需要的资源了。&lt;/p&gt;
&lt;p&gt;IoC很好的体现了面向对象设计法则之一—— 好莱坞法则：“别找我们，我们找你”；即由IoC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IoC和DI&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;DI—Dependency Injection，即“依赖注入”：组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。&lt;/p&gt;
&lt;p&gt;理解DI的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”，那我们来深入分析一下：&lt;/p&gt;
&lt;p&gt;•谁依赖于谁：当然是应用程序依赖于IoC容器；&lt;/p&gt;
&lt;p&gt;•为什么需要依赖：应用程序需要IoC容器来提供对象需要的外部资源；&lt;/p&gt;
&lt;p&gt;•谁注入谁：很明显是IoC容器注入应用程序某个对象，应用程序依赖的对象；&lt;/p&gt;
&lt;p&gt;•注入了什么：就是注入某个对象所需要的外部资源（包括对象、资源、常量数据）。&lt;/p&gt;
&lt;p&gt;IoC和DI由什么关系呢？其实它们是同一个概念的不同角度描述，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：“依赖注入”，相对IoC 而言，“依赖注入”明确描述了“被注入对象依赖IoC容器配置依赖对象”。&lt;/p&gt;
&lt;p&gt;对于Spring Ioc这个核心概念，我相信每一个学习Spring的人都会有自己的理解。这种概念上的理解没有绝对的标准答案，仁者见仁智者见智。 理解了IoC和DI的概念后，一切都将变得简单明了，剩下的工作只是在框架中堆积木而已。&lt;/p&gt;
&lt;p&gt;注：转载于 &lt;a href=&quot;https://github.com/biezhi/java-bible/blob/master/ioc/1.concept.md&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/biezhi/java-bible/blob/master/ioc/1.concept.md&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://www.tinymood.com/wp-content/uploads/2016/02/2016021903563940.png&quot; alt=&quot;HLyJOSv&quot;&gt;&lt;br&gt;&lt;strong&gt;什么是IOC？&lt;/strong&gt;&lt;br&gt;IoC(Inve
    
    </summary>
    
      <category term="编织未来" scheme="https://lemonjing.github.io/categories/%E7%BC%96%E7%BB%87%E6%9C%AA%E6%9D%A5/"/>
    
    
      <category term="Java" scheme="https://lemonjing.github.io/tags/Java/"/>
    
      <category term="ioc" scheme="https://lemonjing.github.io/tags/ioc/"/>
    
      <category term="spring" scheme="https://lemonjing.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>『原创』当我们说出故乡时它早已不存在</title>
    <link href="https://lemonjing.github.io/2016/02/10/17/"/>
    <id>https://lemonjing.github.io/2016/02/10/17/</id>
    <published>2016-02-10T10:17:17.000Z</published>
    <updated>2016-03-07T07:22:43.909Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;http://www.tinymood.com/wp-content/uploads/2016/02/2016021010035974.jpg&quot; alt=&quot;IMG_3023&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #00ccff;&quot;&gt;如果有，那一定是在10多年前家乡小河边，在炎炎夏日灼烧后我跳进小河中戏水后眼角沾着水珠在夕阳光线散射的五彩斑斓中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;年前1月16号就已经放假了，当然可以回家，当然想回家。但是内心又觉得回家去干嘛呢，姐姐早已结婚，上班。母亲，上班。父亲，上班。家乡人家的屋子随着城镇化进程早已被拆的七零八落。于是乎，在学校又坚持做了2个星期的工作，然后带着一点点希许踏上回家漫漫路。回家后才发现记忆中的一切都被摧毁，如果说还剩下什么，大概只有儿时种下的几株树还是挺拔地屹立着，其中一棵记忆中一直很弱小，小时候的我每每担心它会死掉而不愿将秋千系在它身上的小小树，如今却也长成了几十米高，当我看到后却是有一种惊讶而又欣慰的感情，无法言说。老一辈的孩子王已经长大结婚，曾经一起玩弹珠，跳皮筋，丢沙包，打雪仗，下河捉虾，掏螃蟹洞，上树掏鸟窝的小伙伴们你们又在哪里？我分外想念，但却又不想去见你们。我怕我无法融入到你们的话题中。你们说“你有女朋友了吗？你女朋宇哪里人？你现在在做什么工作？打算什么时候结婚？啊，你还在读书啊？读这么多有什么用啊？告诉你，前年东头的王牙子生了个大胖娃哦……”你们所热衷的话题，我却是无法参与其中。我想去试着感受你们的快乐，却是无法成功。一闭眼就能想到自己未来10年，20年，30年，甚至更多时间的以后的生活的样子，太可怕了，我不敢去想。都说人生如戏，可是精彩的戏不应当是步步惊心，充满变数，吊足观众胃口却又让观众猜不到结局的么？难道不是吗？可现在呢，你们这哪里是戏，或者说即使是戏，也是部坏戏，是一部从头到尾的烂戏，因为看到了开头就早已知道结尾，平淡的没有一丝涟漪。早早结婚生子，担心孩子的小学，初中，高中，大学，孩子结婚，生子，担心……人生如戏，这戏不应该这么平淡呀。曾经的好男儿啊，岁月竟如此可怕，将你们的棱角磨的这般平滑。更让我伤心的是，不知何时，咱们早已没有后辈去继承我们的“光辉历史”了，他们都在补习在舞蹈班都在pad在电脑，再也没人给我们的小兔子喂菜，踢几脚还在睡懒觉的小刺猬，或是守在高压线下等着傻乎乎的野鸡触电，然后饱餐一顿烧烤大餐。真的，我们是最后的一代，在田地里长大的最后一代。真是令人唏嘘不已。&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;原本，说起故乡应当是令人感到宽慰而感动，无需表演，不用伪装，一片真心，心的归属之地。可是我回到家都是如此情形。“TR，你以后去哪找工作啊？”“我想去大城市，工作机会多，而且我们专业在WH没什么公司，不好找的。”“什么？WH怎么可能没你的工作！我看你就是眼光高，读书怎么了，我们厂里大学生挣的还没我们多”“TR，我跟你讲现在的女孩子都特别傲气，现在不找就找不到了”，“你带回来的这个还蛮好看的，是真的吗？下次能再多带些嘛”，“你们现在读书都把脑子读坏了吧，这个东西都不会”，诸如此类，很多很多。不是特别亲的亲戚，但都是认识的，我听完都不知如何去接话，只是呵呵一笑了之。她们真的不是坏心，但说出来的话却让我气不知从何出，只能抑着。孩提时我所认为的好伯伯们好阿姨们啊，虽然不是你们的错，却让我认清了回忆和现状的巨大差别。夏虫不可语于冰，井蛙不可语于海。古人诚不欺于我。&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;小时候在村里长大，在田里地里播种，河里捉鱼摸虾，掏鸟窝，逮兔子，捉野鸡，都是如此稀松平常，可这个画面注定只能封存在记忆中了，不愉快却又很无力。为了发展，为了经济，我不知这种破坏或是拆迁的举措是否真的值得。但现实是。真的这样做了。至于我，希望人生这部戏能够精彩，能够耐人寻味，能够引人入胜，而不是猜中开头即是结局这般。而对于穷苦家的孩子来说，也只有去读书了。所以，踏上求学之路，曾经做上30多个小时的绿皮火车，那滋味我至今难忘；在火车站熬夜，辗转多地，更换多种交通方式；一个人在陌生的城市问路；一个人在冬天的冷风中拖着行李瑟瑟发抖；太多太多。求学真的如此容易么？求学并不容易啊。我的一些天高地远的小伙伴们回家，求学的经历简直就是一部励志电影，每每让我打心里佩服，愿意竖起10个大拇指加脚趾的那种。至于现在，因为一个人所经历的事情带来的影响，很多事都不再怕了，什么都不介意了，微微笑就可以了，好事或事坏事，寂寞或是孤单。一个人在奶茶店认真的写作，一个人在图书馆读着被你们说做少女心的简爱，一个人在午夜时间的实验室霹雳吧啦的敲代码，在海边沙滩上不顾他人眼光用树枝写下新年祝福，买了2张票去邀请人看电影被拒后一个人做着两个座位欣赏电影也是怡然自得，然后一个人打着麻药就做了人生的第一次手术，找一天时间躲在宿舍看一天感人电影然后哭得稀里哗啦第二天和别人聊天说自己看什么电影都不哭，一个人去到陌生城市请教陌生的人…….你问我，你怕么？我怕，我怕极了，我怕我考虑的多了，就错过机会了，我怕时间不等人，我怕若是自己一时的不如意而落下心结。我怕极了所有的一切。可是，正因为怕我才要去做，去克服去战胜自己，这种经历简直美妙。你试试就知道了。&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;现在的我早已不是过去的我了，可现在的我还是过去的我。如果你遇到我，和我讨论故乡，其实我告诉你的已经不是事实不是真相，但是，请你记住，我告诉你的关于故乡的样子，它就是故乡本来的样子。&lt;/p&gt;
&lt;p&gt;当我们说出远方，远方已是虚妄。&lt;br&gt;当我们说出故乡，故乡已不再存在。&lt;/p&gt;
&lt;p&gt;不是年味越来越淡了，虽然极不愿意承认，但坦白的说，其实是因为我们－－长大了。&lt;br&gt;人如尘埃，渺渺茫茫，珍惜一切，不沉浸在逝去的过去，只要微笑就可以了。而在心里最柔软的地方，它仍旧是我的故乡所在。&lt;/p&gt;
&lt;center&gt;&lt;span style=&quot;color: #00ccff;&quot;&gt;心里若有了薄凉，如此，不再无病呻吟，兀自惆怅&lt;/span&gt;&lt;br&gt;&lt;span style=&quot;color: #00ccff;&quot;&gt; 欢迎来到小情绪，&lt;/span&gt;&lt;br&gt;&lt;span style=&quot;color: #00ccff;&quot;&gt; 访问tinymood.com阅读、聆听、讨论，一起相拥文字的温度…&lt;/span&gt;&lt;br&gt;&lt;span style=&quot;color: #00ccff;&quot;&gt; 新浪微博&lt;a href=&quot;http://weibo.com/u/1662536394&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@Campanulaece&lt;/a&gt;－桔梗，分享你的故事以及更多&lt;/span&gt;&lt;br&gt;&lt;span style=&quot;color: #00ccff;&quot;&gt; ——TinyMood.COM&lt;/span&gt;&lt;/center&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://www.tinymood.com/wp-content/uploads/2016/02/2016021010035974.jpg&quot; alt=&quot;IMG_3023&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #00ccff;&quot;&gt;如
    
    </summary>
    
      <category term="小情绪" scheme="https://lemonjing.github.io/categories/%E5%B0%8F%E6%83%85%E7%BB%AA/"/>
    
      <category term="随笔" scheme="https://lemonjing.github.io/categories/%E5%B0%8F%E6%83%85%E7%BB%AA/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="原创" scheme="https://lemonjing.github.io/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="故乡" scheme="https://lemonjing.github.io/tags/%E6%95%85%E4%B9%A1/"/>
    
  </entry>
  
  <entry>
    <title>6种单例模式的实现以及double check的剖析</title>
    <link href="https://lemonjing.github.io/2016/02/06/2/"/>
    <id>https://lemonjing.github.io/2016/02/06/2/</id>
    <published>2016-02-06T14:40:31.000Z</published>
    <updated>2016-03-07T07:22:43.908Z</updated>
    
    <content type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/Lemonjing/TinyMood/blob/master/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/singleton.md&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;点击阅读Github Markdown原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.tinymood.com/wp-content/uploads/2016/02/2016022914301353.png&quot; alt=&quot;design&quot;&gt;&lt;br&gt;&lt;strong&gt;如何正确地写出单例模式&lt;/strong&gt;&lt;br&gt;单例模式算是设计模式中最容易理解，也是最容易手写代码的模式了吧。但是其中的坑却不少，所以也常作为面试题来考。本文主要对几种单例写法的整理，并分析其优缺点。很多都是一些老生常谈的问题，但如果你不知道如何创建一个线程安全的单例，不知道什么是双检锁，那这篇文章可能会帮助到你。&lt;/p&gt;
&lt;h2 id=&quot;1-懒加载-线程不安全&quot;&gt;&lt;a href=&quot;#1-懒加载-线程不安全&quot; class=&quot;headerlink&quot; title=&quot;1.懒加载 线程不安全&quot;&gt;&lt;/a&gt;1.懒加载 线程不安全&lt;/h2&gt;&lt;p&gt;当被问到要实现一个单例模式时，很多人的第一反应是写出如下的代码，包括教科书上也是这样教我们的。&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;prettyprint linenums&quot;&gt;public class Singleton {&lt;br&gt;    private static Singleton uniqueInstance;&lt;br&gt;    private Singleton (){}&lt;/pre&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static Singleton getInstance() {
 if (uniqueInstance == null) {
     uniqueInstance = new Singleton();
 }
 return uniqueInstance;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;}&lt;br&gt;&lt;br&gt;这段代码简单明了，而且使用了懒加载模式，但是却存在致命的问题。当有多个线程并行调用 getInstance() 的时候，就会创建多个实例。也就是说在多线程下不能正常工作。&lt;/p&gt;
&lt;h2 id=&quot;2-懒加载-线程安全&quot;&gt;&lt;a href=&quot;#2-懒加载-线程安全&quot; class=&quot;headerlink&quot; title=&quot;2.懒加载 线程安全&quot;&gt;&lt;/a&gt;2.懒加载 线程安全&lt;/h2&gt;&lt;p&gt;为了解决上面的问题，最简单的方法是将整个 getInstance() 方法设为同步（synchronized）。&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;prettyprint linenums&quot;&gt;public static synchronized Singleton getInstance() {&lt;br&gt;    if (uniqueInstance == null) {&lt;br&gt;        uniqueInstance = new Singleton();&lt;br&gt;    }&lt;br&gt;    return uniqueInstance;&lt;br&gt;}&lt;br&gt;&lt;/pre&gt;&lt;br&gt;虽然做到了线程安全，并且解决了多实例的问题，但是它并不高效。因为在任何时候只能有一个线程调用 getInstance() 方法。但是同步操作只需要在第一次调用时才被需要，即第一次创建单例实例对象时。这就引出了双重检验锁。&lt;/p&gt;
&lt;h2 id=&quot;3-双重检查加锁-线程安全&quot;&gt;&lt;a href=&quot;#3-双重检查加锁-线程安全&quot; class=&quot;headerlink&quot; title=&quot;3.双重检查加锁 线程安全&quot;&gt;&lt;/a&gt;3.双重检查加锁 线程安全&lt;/h2&gt;&lt;p&gt;双重检验加锁模式（double checked locking pattern），是一种使用同步块加锁的方法。程序员称其为双重检查锁，因为会有两次检查 uniqueInstance == null，一次是在同步块外，一次是在同步块内。为什么在同步块内还要再检验一次？因为可能会有多个线程一起进入同步块外的 if，如果在同步块内不进行二次检验的话就会生成多个实例了。&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;prettyprint linenums&quot;&gt;public static Singleton getSingleton() {&lt;br&gt;    if (uniqueInstance == null) {                         //Single Checked&lt;br&gt;        synchronized (Singleton.class) {&lt;br&gt;            if (uniqueInstance == null) {                 //Double Checked&lt;br&gt;                uniqueInstance = new Singleton();&lt;br&gt;            }&lt;br&gt;        }&lt;br&gt;    }&lt;br&gt;    return uniqueInstance;&lt;br&gt;}&lt;br&gt;&lt;/pre&gt;&lt;br&gt;这段代码看起来很完美，很可惜，它是有问题。主要在于uniqueInstance = new Singleton()这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情。&lt;/p&gt;
&lt;p&gt;给 uniqueInstance 分配内存&lt;br&gt;调用 Singleton 的构造函数来初始化成员变量&lt;br&gt;将uniqueInstance对象指向分配的内存空间（执行完这步 uniqueInstance 就为非 null 了）&lt;br&gt;但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时uniqueInstance已经是非 null 了（但却没有初始化），所以线程二会直接返回 uniqueInstance，然后使用，然后顺理成章地报错。&lt;/p&gt;
&lt;p&gt;我们只需要将 uniqueInstance 变量声明成 volatile 就可以了。&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;prettyprint linenums&quot;&gt;public class Singleton {&lt;br&gt;    private volatile static Singleton uniqueInstance; //声明成 volatile&lt;br&gt;    private Singleton (){}&lt;/pre&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static Singleton getSingleton() {
    if (uniqueInstance == null) {                         
        synchronized (Singleton.class) {
            if (uniqueInstance == null) {       
                uniqueInstance = new Singleton();
            }
        }
    }
    return uniqueInstance;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;}&lt;br&gt;&lt;br&gt;有些人认为使用 volatile 的原因是可见性，也就是可以保证线程在本地不会存有 uniqueInstance 的副本，每次都是去主内存中读取。但其实是不对的。使用 volatile 的主要原因是其另一个特性：禁止指令重排序优化。也就是说，在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前。比如上面的例子，取操作必须在执行完 1-2-3 之后或者 1-3-2 之后，不存在执行到 1-3 然后取到值的情况。从「先行发生原则」的角度理解的话，就是对于一个 volatile 变量的写操作都先行发生于后面对这个变量的读操作（这里的“后面”是时间上的先后顺序）。&lt;/p&gt;
&lt;p&gt;但是特别注意在 Java 5 以前的版本使用了 volatile 的双检锁还是有问题的。其原因是 Java 5 以前的 JMM （Java 内存模型）是存在缺陷的，即时将变量声明成 volatile 也不能完全避免重排序，主要是 volatile 变量前后的代码仍然存在重排序问题。这个 volatile 屏蔽重排序的问题在 Java 5 中才得以修复，所以在这之后才可以放心使用 volatile。&lt;/p&gt;
&lt;p&gt;相信你不会喜欢这种复杂又隐含问题的方式，当然我们有更好的实现线程安全的单例模式的办法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.tinymood.com/wp-content/uploads/2016/02/2016020614503852.jpg&quot; alt=&quot;u=3016183366,3592358855&amp;amp;fm=21&amp;amp;gp=0&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;4-急加载-static-final-field-线程安全&quot;&gt;&lt;a href=&quot;#4-急加载-static-final-field-线程安全&quot; class=&quot;headerlink&quot; title=&quot;4.急加载 static final field 线程安全&quot;&gt;&lt;/a&gt;4.急加载 static final field 线程安全&lt;/h2&gt;&lt;p&gt;这种方法非常简单，因为单例的实例被声明成 static 和 final 变量了，在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;prettyprint linenums&quot;&gt;public class Singleton{&lt;br&gt;    //类加载时就初始化&lt;br&gt;    private static final Singleton uniqueInstance = new Singleton();&lt;/pre&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private Singleton(){}

public static Singleton getInstance(){
    return uniqueInstance;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;}&lt;br&gt;&lt;br&gt;这种写法如果完美的话，就没必要在啰嗦那么多双检锁的问题了。缺点是它不是一种懒加载模式（lazy initialization），单例会在加载类后一开始就被初始化，即使客户端没有调用 getInstance()方法。饿汉式的创建方式在一些场景中将无法使用：譬如 Singleton 实例的创建是依赖参数或者配置文件的，在 getInstance() 之前必须调用某个方法设置参数给它，那样这种单例写法就无法使用了。&lt;/p&gt;
&lt;h2 id=&quot;5-静态内部类-static-nested-class-线程安全&quot;&gt;&lt;a href=&quot;#5-静态内部类-static-nested-class-线程安全&quot; class=&quot;headerlink&quot; title=&quot;5.静态内部类 static nested class 线程安全&quot;&gt;&lt;/a&gt;5.静态内部类 static nested class 线程安全&lt;/h2&gt;&lt;p&gt;我比较倾向于使用静态内部类的方法，这种方法也是《Effective Java》上所推荐的。&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;prettyprint linenums&quot;&gt;public class Singleton {&lt;br&gt;    private static class SingletonHolder {&lt;br&gt;        private static final Singleton uniqueInstance = new Singleton();&lt;br&gt;    }&lt;br&gt;    private Singleton (){}&lt;br&gt;    public static final Singleton getInstance() {&lt;br&gt;        return SingletonHolder.uniqueInstance;&lt;br&gt;    }&lt;br&gt;}&lt;br&gt;&lt;/pre&gt;&lt;br&gt;这种写法仍然使用JVM本身机制保证了线程安全问题；由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它是懒加载的；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。&lt;/p&gt;
&lt;h2 id=&quot;6-枚举-Enum-线程安全&quot;&gt;&lt;a href=&quot;#6-枚举-Enum-线程安全&quot; class=&quot;headerlink&quot; title=&quot;6.枚举 Enum 线程安全&quot;&gt;&lt;/a&gt;6.枚举 Enum 线程安全&lt;/h2&gt;&lt;p&gt;用枚举写单例实在太简单了！这也是它最大的优点。下面这段代码就是声明枚举实例的通常做法。&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;prettyprint linenums&quot;&gt;public enum EasySingleton{&lt;br&gt;    INSTANCE;&lt;br&gt;}&lt;br&gt;&lt;/pre&gt;&lt;br&gt;我们可以通过EasySingleton.INSTANCE来访问实例，这比调用getInstance()方法简单多了。创建枚举默认就是线程安全的，所以不需要担心double checked locking，而且还能防止反序列化导致重新创建新的对象。但是还是很少看到有人这样写，可能是因为不太熟悉吧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;br&gt;一般来说，单例模式有五种写法：懒加载、急加载、双重检查加锁锁、静态内部类、枚举。上述所说都是线程安全的实现，文章开头给出的第一种方法不算正确的写法。&lt;/p&gt;
&lt;p&gt;就我个人而言，一般情况下直接使用急加载就好了，如果明确要求要懒加载（lazy initialization）会倾向于使用静态内部类，如果涉及到反序列化创建对象时会试着使用枚举的方式来实现单例。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码打包&lt;/strong&gt;&lt;br&gt;完整代码 &lt;a href=&quot;https://github.com/Lemonjing/designpattern/tree/master/src/com/tinymood/designpattern/singleton&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Singleton&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Read More&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://javarevisited.blogspot.sg/2014/05/double-checked-locking-on-singleton-in-java.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Double Checked Locking on Singleton Class in Java&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://javarevisited.blogspot.sg/2012/07/why-enum-singleton-are-better-in-java.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://javarevisited.blogspot.sg/2012/07/why-enum-singleton-are-better-in-java.html&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://javarevisited.blogspot.com/2012/12/how-to-create-thread-safe-singleton-in-java-example.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;How to create thread safe Singleton in Java&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://javarevisited.blogspot.com/2011/03/10-interview-questions-on-singleton.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;10 Singleton Pattern Interview questions in Java&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/Lemonjing/TinyMood/blob/master/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/singleton.md&quot; target=&quot;_blank&quot; rel=&quot;extern
    
    </summary>
    
      <category term="编织未来" scheme="https://lemonjing.github.io/categories/%E7%BC%96%E7%BB%87%E6%9C%AA%E6%9D%A5/"/>
    
    
      <category term="Java" scheme="https://lemonjing.github.io/tags/Java/"/>
    
      <category term="单例" scheme="https://lemonjing.github.io/tags/%E5%8D%95%E4%BE%8B/"/>
    
      <category term="设计模式" scheme="https://lemonjing.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java注解 － 注解处理器</title>
    <link href="https://lemonjing.github.io/2016/02/05/69/"/>
    <id>https://lemonjing.github.io/2016/02/05/69/</id>
    <published>2016-02-05T07:47:11.000Z</published>
    <updated>2016-03-07T07:22:43.908Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;http://7xlkoc.com1.z0.glb.clouddn.com/java0.jpg&quot; alt=&quot;&quot; title=&quot;茶馆、岛、慵懒的猫...都是美好的时光...&quot;&gt;&lt;br&gt;接上文深入理解Java注解 －注解入门&lt;br&gt;如果没有用来读取注解的方法和工作，那么注解也就不会比注释更有用处了。使用注解的过程中，很重要的一部分就是创建于使用注解处理器。Java5扩展了反射机制的API，以帮助程序员快速的构造自定义注解处理器。&lt;/p&gt;
&lt;h2 id=&quot;注解处理器类库-java-lang-reflect-AnnotatedElement&quot;&gt;&lt;a href=&quot;#注解处理器类库-java-lang-reflect-AnnotatedElement&quot; class=&quot;headerlink&quot; title=&quot;注解处理器类库(java.lang.reflect.AnnotatedElement)&quot;&gt;&lt;/a&gt;注解处理器类库(java.lang.reflect.AnnotatedElement)&lt;/h2&gt;&lt;p&gt;Java使用Annotation接口来代表程序元素前面的注解，该接口是所有Annotation类型的父接口。除此之外，Java在java.lang.reflect 包下新增了AnnotatedElement接口，该接口代表程序中可以接受注解的程序元素，该接口主要有如下几个实现类：&lt;/p&gt;
&lt;p&gt;Class：类定义&lt;br&gt;Constructor：构造器定义&lt;br&gt;Field：累的成员变量定义&lt;br&gt;Method：类的方法定义&lt;br&gt;Package：类的包定义&lt;/p&gt;
&lt;p&gt;java.lang.reflect 包下主要包含一些实现反射功能的工具类，实际上，java.lang.reflect 包所有提供的反射API扩充了读取运行时Annotation信息的能力。当一个Annotation类型被定义为运行时的Annotation后，该注解才能是运行时可见，当class文件被装载时被保存在class文件中的Annotation才会被虚拟机读取。&lt;/p&gt;
&lt;p&gt;AnnotatedElement 接口是所有程序元素（Class、Method和Constructor）的父接口，所以程序通过反射获取了某个类的AnnotatedElement对象之后，程序就可以调用该对象的如下四个个方法来访问Annotation信息：&lt;/p&gt;
&lt;p&gt;方法1： T getAnnotation(Class annotationClass):返回改程序元素上存在的、指定类型的注解，如果该类型注解不存在，则返回null。&lt;br&gt;方法2：Annotation[] getAnnotations():返回该程序元素上存在的所有注解。&lt;br&gt;方法3：boolean is AnnotationPresent(Class&amp;lt;?extends Annotation&amp;gt; annotationClass):判断该程序元素上是否包含指定类型的注解，存在则返回true，否则返回false.&lt;br&gt;方法4：Annotation[] getDeclaredAnnotations()：返回直接存在于此元素上的所有注释。与此接口中的其他方法不同，该方法将忽略继承的注解。（如果没有注解直接存在于此元素上，则返回长度为零的一个数组。）该方法的调用者可以随意修 改返回的数组；这不会对其他调用者返回的数组产生任何影响。&lt;/p&gt;
&lt;p&gt;一个简单的注解处理器：　　&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;prettyprint linenums&quot;&gt;&lt;br&gt;/&lt;strong&gt;&lt;strong&gt;&lt;em&gt;*&lt;/em&gt;&lt;/strong&gt;&lt;/strong&gt;注解声明&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;em&gt;*&lt;/em&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;/&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;/**&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;水果名称注解&lt;/li&gt;
&lt;li&gt;@author taoxiaoran&lt;br&gt;&lt;em&gt;
&lt;/em&gt;/&lt;br&gt;@Target(ElementType.FIELD)&lt;br&gt;@Retention(RetentionPolicy.RUNTIME)&lt;br&gt;@Documented&lt;br&gt;public @interface FruitName {&lt;br&gt; String value() default “”;&lt;br&gt;}&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;/**&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;水果颜色注解&lt;/li&gt;
&lt;li&gt;&lt;p&gt;@author peida&lt;br&gt;&lt;em&gt;
&lt;/em&gt;/&lt;br&gt;@Target(ElementType.FIELD)&lt;br&gt;@Retention(RetentionPolicy.RUNTIME)&lt;br&gt;@Documented&lt;br&gt;public @interface FruitColor {&lt;br&gt; /**&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;颜色枚举&lt;/li&gt;
&lt;li&gt;&lt;p&gt;@author peida&lt;br&gt;&lt;em&gt;
&lt;/em&gt;/&lt;br&gt;public enum Color{ BULE,RED,GREEN};&lt;/p&gt;
&lt;p&gt;/**&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;颜色属性&lt;/li&gt;
&lt;li&gt;@return&lt;br&gt;*/&lt;br&gt;Color fruitColor() default Color.GREEN;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;/**&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;水果供应者注解&lt;/li&gt;
&lt;li&gt;&lt;p&gt;@author peida&lt;br&gt;&lt;em&gt;
&lt;/em&gt;/&lt;br&gt;@Target(ElementType.FIELD)&lt;br&gt;@Retention(RetentionPolicy.RUNTIME)&lt;br&gt;@Documented&lt;br&gt;public @interface FruitProvider {&lt;br&gt; /**&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;供应商编号&lt;/li&gt;
&lt;li&gt;&lt;p&gt;@return&lt;br&gt;*/&lt;br&gt;public int id() default -1;&lt;/p&gt;
&lt;p&gt;/**&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;供应商名称&lt;/li&gt;
&lt;li&gt;&lt;p&gt;@return&lt;br&gt;*/&lt;br&gt;public String name() default “”;&lt;/p&gt;
&lt;p&gt;/**&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;供应商地址&lt;/li&gt;
&lt;li&gt;@return&lt;br&gt;*/&lt;br&gt;public String address() default “”;&lt;br&gt;}&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;/&lt;strong&gt;&lt;strong&gt;&lt;em&gt;*&lt;/em&gt;&lt;/strong&gt;&lt;/strong&gt;注解使用&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;em&gt;*&lt;/em&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;/&lt;/p&gt;
&lt;p&gt;public class Apple {&lt;br&gt;    @FruitName(“Apple”)&lt;br&gt;    private String appleName;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@FruitColor(fruitColor=Color.RED)
private String appleColor;

@FruitProvider(id=1,name=&amp;quot;陕西红富士集团&amp;quot;,address=&amp;quot;陕西省西安市延安路89号红富士大厦&amp;quot;)
private String appleProvider;

public void setAppleColor(String appleColor) {
    this.appleColor = appleColor;
}

public String getAppleColor() {
    return appleColor;
}

public void setAppleName(String appleName) {
    this.appleName = appleName;
}

public String getAppleName() {
    return appleName;
}

public void setAppleProvider(String appleProvider) {
    this.appleProvider = appleProvider;
}

public String getAppleProvider() {
    return appleProvider;
}

public void displayName(){
    System.out.println(&amp;quot;水果的名字是：苹果&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;/&lt;strong&gt;&lt;strong&gt;&lt;em&gt;*&lt;/em&gt;&lt;/strong&gt;&lt;/strong&gt;注解处理器&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;em&gt;*&lt;/em&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;/&lt;/p&gt;
&lt;p&gt;public class FruitInfoUtil {&lt;br&gt;    public static void getFruitInfo(Class&amp;lt;?&amp;gt; clazz){&lt;br&gt;        String strFruitName=” 水果名称：”;&lt;br&gt;        String strFruitColor=” 水果颜色：”;&lt;br&gt;        String strFruitProvicer=”供应商信息：”;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    Field[] fields = clazz.getDeclaredFields();

    for(Field field :fields){
        if(field.isAnnotationPresent(FruitName.class)) {
            FruitName fruitName = (FruitName) field.getAnnotation(FruitName.class);
            strFruitName=strFruitName+fruitName.value();
            System.out.println(strFruitName);
        } else if(field.isAnnotationPresent(FruitColor.class)) {
            FruitColor fruitColor= (FruitColor) field.getAnnotation(FruitColor.class);
            strFruitColor=strFruitColor+fruitColor.fruitColor().toString();
            System.out.println(strFruitColor);
        } else if(field.isAnnotationPresent(FruitProvider.class)) {
            FruitProvider fruitProvider= (FruitProvider) field.getAnnotation(FruitProvider.class);
            strFruitProvicer=&amp;quot; 供应商编号：&amp;quot;+fruitProvider.id()+&amp;quot; 供应商名称：&amp;quot;+fruitProvider.name()+&amp;quot; 供应商地址：&amp;quot;+fruitProvider.address();
            System.out.println(strFruitProvicer);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;/&lt;strong&gt;&lt;strong&gt;&lt;em&gt;*&lt;/em&gt;&lt;/strong&gt;&lt;/strong&gt;输出结果&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;em&gt;*&lt;/em&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;/&lt;br&gt;public class FruitRun {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * @param args
 */
public static void main(String[] args) {
    FruitInfoUtil.getFruitInfo(Apple.class);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;====================================&lt;br&gt; 水果名称：Apple&lt;br&gt; 水果颜色：RED&lt;br&gt; 供应商编号：1 供应商名称：陕西红富士集团 供应商地址：陕西省西安市延安路89号红富士大厦&lt;br&gt;&lt;br&gt;&lt;strong&gt;Java注解的基础知识点导图&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;http://images.cnitblog.com/blog/34483/201304/25200814-475cf2f3a8d24e0bb3b4c442a4b44734.jpg&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/2b8bbd8db79a1959e403a3bc56fbd89e27fcd38d/687474703a2f2f696d616765732e636e6974626c6f672e636f6d2f626c6f672f33343438332f3230313330342f32353230303831342d34373563663266336138643234653062623362346334343261346234343733342e6a7067&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;br&gt;本文转自博客园 地址 &lt;a href=&quot;http://www.cnblogs.com/peida&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/peida&lt;/a&gt; 本人略有修改。2015-11-2&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xlkoc.com1.z0.glb.clouddn.com/java0.jpg&quot; alt=&quot;&quot; title=&quot;茶馆、岛、慵懒的猫...都是美好的时光...&quot;&gt;&lt;br&gt;接上文深入理解Java注解 －注解入门&lt;br&gt;如果没有用来读取注解的方法
    
    </summary>
    
      <category term="编织未来" scheme="https://lemonjing.github.io/categories/%E7%BC%96%E7%BB%87%E6%9C%AA%E6%9D%A5/"/>
    
    
      <category term="Java" scheme="https://lemonjing.github.io/tags/Java/"/>
    
      <category term="注解" scheme="https://lemonjing.github.io/tags/%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Git忽略规则及.gitignore规则不生效的解决办法</title>
    <link href="https://lemonjing.github.io/2016/01/25/80/"/>
    <id>https://lemonjing.github.io/2016/01/25/80/</id>
    <published>2016-01-25T07:48:09.000Z</published>
    <updated>2016-03-07T07:22:43.908Z</updated>
    
    <content type="html">&lt;p&gt;&lt;center&gt;&lt;span style=&quot;color: red;&quot;&gt;本文转载于梧桐树下&lt;a href=&quot;http://www.pfeng.org/archives/840，站长已测试该解决办法。&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.pfeng.org/archives/840，站长已测试该解决办法。&lt;/a&gt;&lt;/span&gt;&lt;/center&gt;&lt;br&gt;&lt;img src=&quot;http://www.tinymood.com/wp-content/uploads/2016/01/2016022914353610.png&quot; alt=&quot;github1&quot;&gt;&lt;/p&gt;
&lt;p&gt;在git中如果想忽略掉某个文件，不让这个文件提交到版本库中，可以使用修改根目录中 .gitignore 文件的方法（如无，则需自己手工建立此文件）。这个文件每一行保存了一个匹配的规则例如：&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums&quot;&gt;# 此为注释 – 将被 Git 忽略
*.a       # 忽略所有 .a 结尾的文件
!lib.a    # 但 lib.a 除外
/TODO     # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO
build/    # 忽略 build/ 目录下的所有文件
doc/*.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt
# 此为注释 – 将被 Git 忽略
&lt;/pre&gt;
规则很简单，不做过多解释，但是有时候在项目开发过程中，突然心血来潮想把某些目录或文件加入忽略规则，按照上述方法定义后发现并未生效，原因是.gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。那么解决方法就是先把本地缓存删除（改变成未track状态），然后再提交：
&lt;pre class=&quot;prettyprint linenums&quot;&gt;git rm -r --cached .
git add .
git commit -m &#39;update .gitignore&#39;
&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;center&gt;&lt;span style=&quot;color: red;&quot;&gt;本文转载于梧桐树下&lt;a href=&quot;http://www.pfeng.org/archives/840，站长已测试该解决办法。&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://
    
    </summary>
    
      <category term="编织未来" scheme="https://lemonjing.github.io/categories/%E7%BC%96%E7%BB%87%E6%9C%AA%E6%9D%A5/"/>
    
    
      <category term="git" scheme="https://lemonjing.github.io/tags/git/"/>
    
      <category term="gitignore" scheme="https://lemonjing.github.io/tags/gitignore/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC利用Column 注解约束double类型的精度</title>
    <link href="https://lemonjing.github.io/2016/01/23/85/"/>
    <id>https://lemonjing.github.io/2016/01/23/85/</id>
    <published>2016-01-23T11:39:08.000Z</published>
    <updated>2016-03-07T07:22:43.908Z</updated>
    
    <content type="html">&lt;p&gt;最近做了一个小系统，主要是和.net开发的客户端交互一些数据，采用springmvc框架做的，数据库采用的是mysql，另外为了方面使用了注解方式，省掉了许多配置文件。数据库持久化采用的是hibernate，也采用了注解，相比以往要的xml文件进行映射，注解方便了不少，但是也遇到一些问题。比如pojo中有的字段类是业务需要，不需要映射到数据库，即使没有加上@Column注解，默认也会在数据库增加一个和java类中field同名的列，如果不想在数据库增加，需要加上@Transient的注解。这个还比较容易在网上查到。另外一个问题花了一点时间，问题是这样的，POJO中有个字段，是double类型，想限制一下小数点长度，开始使用的如下格式，&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums&quot;&gt;
@Column(name = &quot;grade&quot;, precision = 5, scale = 2)
private double grade;
&lt;/pre&gt;

&lt;p&gt;不过查看数据库表的创建语句，发现映射到mysql数据库的时候无效，还有说人说要把注解加到字段的get方法上，试了一下，还是不行，最后还是在stackoverflow找到类似的问题，找到了答案。&lt;br&gt;&lt;img src=&quot;http://www.tcxurun.cn/wp-content/uploads/2013/08/1-300x143.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt; 想给double类型加上限制，应该采用如下写法：&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;prettyprint linenums&quot;&gt;&lt;br&gt;@Column(name = “grade”, columnDefinition=”double(10,2) default ‘0.00’”&lt;br&gt;private double grade;&lt;br&gt;&lt;/pre&gt;&lt;br&gt;&lt;img src=&quot;http://www.tcxurun.cn/wp-content/uploads/2013/08/2-300x161.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;strong&gt;参考资料：&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;http://stackoverflow.com/questions/4078559/how-to-specify-doubles-precision-on-hibernate&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://stackoverflow.com/questions/4078559/how-to-specify-doubles-precision-on-hibernate&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://stackoverflow.com/questions/197045/setting-default-values-for-columns-in-jpa&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://stackoverflow.com/questions/197045/setting-default-values-for-columns-in-jpa&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;最近做了一个小系统，主要是和.net开发的客户端交互一些数据，采用springmvc框架做的，数据库采用的是mysql，另外为了方面使用了注解方式，省掉了许多配置文件。数据库持久化采用的是hibernate，也采用了注解，相比以往要的xml文件进行映射，注解方便了不少，但是
    
    </summary>
    
      <category term="编织未来" scheme="https://lemonjing.github.io/categories/%E7%BC%96%E7%BB%87%E6%9C%AA%E6%9D%A5/"/>
    
    
      <category term="Java" scheme="https://lemonjing.github.io/tags/Java/"/>
    
      <category term="Hibernate" scheme="https://lemonjing.github.io/tags/Hibernate/"/>
    
      <category term="JPA" scheme="https://lemonjing.github.io/tags/JPA/"/>
    
  </entry>
  
  <entry>
    <title>『原创』青瓷易懂 情结难解</title>
    <link href="https://lemonjing.github.io/2016/01/16/37/"/>
    <id>https://lemonjing.github.io/2016/01/16/37/</id>
    <published>2016-01-16T07:19:14.000Z</published>
    <updated>2016-03-07T07:22:43.907Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;http://www.tinymood.com/wp-content/uploads/2016/01/2016011607163872.gif&quot; alt=&quot;IMG_2855&quot;&gt;&lt;br&gt;[hermit auto=”1” loop=”1” unexpand=”1” fullheight=”0”]netease_songs#:33314587[/hermit]&lt;/p&gt;
&lt;h2 id=&quot;1&quot;&gt;&lt;a href=&quot;#1&quot; class=&quot;headerlink&quot; title=&quot;1&quot;&gt;&lt;/a&gt;1&lt;/h2&gt;&lt;p&gt;电视剧《青瓷》曾热播了一阵子，看电视时，我断断续续看了几集，在网上又看了第一集和最后一集，感觉演员不错，剧情不错。好友家又恰好有《青瓷》这本书，据说电视剧和书有太多不同，便拿了回家，利用闲暇时候，或粗略或细致地把书看完了。&lt;/p&gt;
&lt;p&gt;确实，电视里头的张仲平，更不食人间烟火些，与江小璐和曾真两个性格迥然不同却又同样美丽善良讨人喜爱的女人，竟然只是暧昧，而无任何实质性的关系。这，可能吗？当然不可能，目的很明显，只是让中青年已婚妇女观众看到一个在当今婚姻制度下的一个守身如玉的完美男人，让她们相信，家庭是最重要的，男人是靠得住的。&lt;/p&gt;
&lt;p&gt;还好，浮石没有让我意外，他的描写，更契合时下的真实状况。江小璐是张忠平的情人，曾真是张仲平的宝贝，之前的，不细写，只是几乎没断过。是呀，这么一个男人，高大英俊，有能力又多金，更要命的是，他还有学识、懂风情，何以不会吸引人呢！？他往返于河东河西，游刃有余而乐在其中。他也有他的原则，即使遇到未婚的可爱的漂亮的甚至长得很像他初恋的曾真，他也不曾想过要离婚。而愈是这般，愈显示出男人山一般的责任感，愈让人迷恋。（一细想，其实不然，于男人而言，离婚，一是破产，二是大多成功男人的奋斗过程必有一个背后的共患难的老婆，离了，自会落下个不好的名声，三是儿女的牵绊。权衡得失，最好不离。）&lt;/p&gt;
&lt;h2 id=&quot;2&quot;&gt;&lt;a href=&quot;#2&quot; class=&quot;headerlink&quot; title=&quot;2&quot;&gt;&lt;/a&gt;2&lt;/h2&gt;&lt;p&gt;再来说说这个曾真。这小妮子，纯美而聪慧，却一不小心陷入了和张仲平的爱的漩涡，爱得干脆，爱得无关乎世俗利益，甚至爱到最后都没后悔。于张仲平，曾真像极了他的初恋，而后来，曾真却替代了他的初恋并以自己单纯真挚的深情虏获了他的心。以真爱换得真情，也许值了吧！&lt;/p&gt;
&lt;p&gt;女人啊，一旦爱了，往往就会爱得无比决绝，被她爱上的男人，便成了她生命中的太阳，虽受到温暖，却愿意受灼伤，也愿意承受承受日落后的凄凉黑暗，为爱痴，为爱狂，为爱不顾一切。这个过程中，自然是有真实存在的幸福，但让女人奋不顾身的往往还有自己想象中的、刻意营造出的种种美好，并且被自己的这种情感和精神感动，于是，便愈发不可自拔了婚外恋，这已不是人人谈之色变的话题了，甚至还慢慢地出现在了我们的周围。态度坚决的，或许只是随便望一眼。中间人士，想想便罢。有欲望的便顺势随波逐流，不怪自己，把责任推在这个人心不古、温饱思淫欲的社会大环境头上。而女人这角色，未婚的、婚了的，有的是情感需求，有的是利益唆使，踏出一步，一步步沉沦。书中的曾真，她追求的便是明知没有结果的雾里看花般的似是而非的“爱”，不能完全拥有，就更加舍不得，更加留恋。不管前方深渊也好，末日也罢。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.tinymood.com/wp-content/uploads/2016/01/2016011609032333.jpg&quot; alt=&quot;862227082226619838&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;3&quot;&gt;&lt;a href=&quot;#3&quot; class=&quot;headerlink&quot; title=&quot;3&quot;&gt;&lt;/a&gt;3&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;也是，人生短暂，几十年而已，能爱上，能被爱，而且这爱还可以深入骨髓，真是可遇而不可求，怎么舍得错过呢？遇到一个合拍的人儿，怎么又会轻易把他（她）从怀中推走呢？&lt;/strong&gt;曾真也舍不得。但这个男人，就是孙悟空，他上了紧箍咒，被唐僧收走之时，你又有何挽留的办法呢？曾真也曾自私过，也有过想占有的冲动。但女人啊，爱得太真太切，即使痛彻心扉也只能选择放手，徒留自己在深夜默默哽咽。或者随时间的流逝，在某一天豁然开朗，或是继续思念，品尽苦涩和离伤，甚至把所经历的这一段无限扩展延伸，然后心存念想：今生有缘无分，只待来生生死相依。&lt;/p&gt;
&lt;p&gt;男人，是坏家伙，有了资本和时间，便希望身畔莺燕环绕，有娇妻有红颜，有家庭有艳遇，有温情有刺激，家花野花统统拥入怀中，满足需要，彰显男人本色。同时，男人也像顽皮的孩子，累了倦了，屁颠屁颠回家了。&lt;/p&gt;
&lt;h2 id=&quot;4&quot;&gt;&lt;a href=&quot;#4&quot; class=&quot;headerlink&quot; title=&quot;4&quot;&gt;&lt;/a&gt;4&lt;/h2&gt;&lt;p&gt;女人，是傻家伙，明知自己傻，却还倾尽柔情，为他绽放，为他舍弃。越爱，越对他仰望，然后一而再地轻贱自己，放低自己一直到尘埃里，遍体鳞伤亦无怨无悔。&lt;br&gt;故事的结尾似乎平静，也似乎隐匿着一场大的风暴。而曾真这个小女子的情结，终究也到了该解的时候。其实，解开了也罢，没解开也好，地球照样自转公转，生活如常天亮天黑。&lt;strong&gt;现实生活也是如此，不应该的两个人，只要互相尊重、理解、包容、珍惜、惦记，淡淡地又深深地牵挂着，也许就够了。（或者，再加一句友人的至理名言—扮演好自己的角色就好。）反正，百年之后，一捧骨灰随风逝，任人评述也无妨。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;span style=&quot;color: #00ccff&quot;&gt;这一段情呀&lt;/span&gt;&lt;br&gt;&lt;span style=&quot;color: #00ccff&quot;&gt; 你是我一生中最意外的遇见&lt;/span&gt;&lt;br&gt;&lt;span style=&quot;color: #00ccff&quot;&gt; 相识、相知&lt;/span&gt;&lt;br&gt;&lt;span style=&quot;color: #00ccff&quot;&gt; 让我经历一段无法奢求地老天荒的感情&lt;/span&gt;&lt;br&gt;&lt;span style=&quot;color: #00ccff&quot;&gt; 我喜欢看你扬起的眉毛&lt;/span&gt;&lt;br&gt;&lt;span style=&quot;color: #00ccff&quot;&gt; 喜欢摸你似笑非笑的脸&lt;/span&gt;&lt;br&gt;&lt;span style=&quot;color: #00ccff&quot;&gt; 喜欢听你的声音&lt;/span&gt;&lt;br&gt;&lt;span style=&quot;color: #00ccff&quot;&gt; 喜欢和你十指相扣，亲密地贴着你&lt;/span&gt;&lt;br&gt;&lt;span style=&quot;color: #00ccff&quot;&gt; 我贪恋你的怀抱，温暖，让人心安&lt;/span&gt;&lt;br&gt;&lt;span style=&quot;color: #00ccff&quot;&gt; 闻着你的气息，深深沉醉&lt;/span&gt;&lt;br&gt;&lt;span style=&quot;color: #00ccff&quot;&gt; 只愿时间停驻，永远定格&lt;/span&gt;&lt;br&gt;&lt;span style=&quot;color: #00ccff&quot;&gt; 可每一次相见&lt;/span&gt;&lt;br&gt;&lt;span style=&quot;color: #00ccff&quot;&gt; 却总触得到离伤&lt;/span&gt;&lt;br&gt;&lt;span style=&quot;color: #00ccff&quot;&gt; 那短暂得无法握住的美好啊&lt;/span&gt;&lt;br&gt;&lt;span style=&quot;color: #00ccff&quot;&gt; 竟能带来无法解除的揪心的疼&lt;/span&gt;&lt;br&gt;&lt;span style=&quot;color: #00ccff&quot;&gt; 我是如此地眷恋你&lt;/span&gt;&lt;br&gt;&lt;span style=&quot;color: #00ccff&quot;&gt; 却只能将思念埋在心底&lt;/span&gt;&lt;br&gt;&lt;span style=&quot;color: #00ccff&quot;&gt; 在寂寞的夜里&lt;/span&gt;&lt;br&gt;&lt;span style=&quot;color: #00ccff&quot;&gt; 任泪水悄然而尽情地滑落&lt;/span&gt;&lt;br&gt;&lt;span style=&quot;color: #00ccff&quot;&gt; 多想&lt;/span&gt;&lt;br&gt;&lt;span style=&quot;color: #00ccff&quot;&gt; 毫无顾忌地与你爱一场&lt;/span&gt;&lt;br&gt;&lt;span style=&quot;color: #00ccff&quot;&gt; 牵你的手&lt;/span&gt;&lt;br&gt;&lt;span style=&quot;color: #00ccff&quot;&gt; 微笑着沐浴在暖暖的阳光下&lt;/span&gt;&lt;br&gt;&lt;span style=&quot;color: #00ccff&quot;&gt; 坦然而满足&lt;/span&gt;&lt;br&gt;&lt;span style=&quot;color: #00ccff&quot;&gt; 也许&lt;/span&gt;&lt;br&gt;&lt;span style=&quot;color: #00ccff&quot;&gt; 你只是我的一个梦&lt;/span&gt;&lt;br&gt;&lt;span style=&quot;color: #00ccff&quot;&gt; 又或许&lt;/span&gt;&lt;br&gt;&lt;span style=&quot;color: #00ccff&quot;&gt; 这一切原本就是一个梦&lt;/span&gt;&lt;br&gt;&lt;span style=&quot;color: #00ccff&quot;&gt; 只是&lt;/span&gt;&lt;br&gt;&lt;span style=&quot;color: #00ccff&quot;&gt; 这个梦里的我&lt;/span&gt;&lt;br&gt;&lt;span style=&quot;color: #00ccff&quot;&gt; 是真的——&lt;/span&gt;&lt;br&gt;&lt;span style=&quot;color: #00ccff&quot;&gt; 醉了&lt;/span&gt;&lt;br&gt;&lt;/div&gt;&lt;br&gt;&lt;strong&gt;作者：一颗小柠檬，艺术系逗比妹子&lt;/strong&gt;&lt;br&gt;&amp;nbsp;&lt;br&gt;&lt;img src=&quot;http://www.tinymood.com/wp-content/uploads/2015/09/2015091014285198.jpg&quot; alt=&quot;qrcode&quot;&gt;&lt;br&gt;&lt;span style=&quot;color: #00ccff&quot;&gt;✪ 感谢时光，不偏不倚，躲过了风口浪尖，让我恰好遇见你。&lt;/span&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://www.tinymood.com/wp-content/uploads/2016/01/2016011607163872.gif&quot; alt=&quot;IMG_2855&quot;&gt;&lt;br&gt;[hermit auto=”1” loop=”1” unexpand=
    
    </summary>
    
      <category term="小情绪" scheme="https://lemonjing.github.io/categories/%E5%B0%8F%E6%83%85%E7%BB%AA/"/>
    
    
      <category term="原创" scheme="https://lemonjing.github.io/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="爱情" scheme="https://lemonjing.github.io/tags/%E7%88%B1%E6%83%85/"/>
    
  </entry>
  
  <entry>
    <title>『原创』也许，我只是想等到一个温暖的人</title>
    <link href="https://lemonjing.github.io/2016/01/16/8/"/>
    <id>https://lemonjing.github.io/2016/01/16/8/</id>
    <published>2016-01-16T01:45:03.000Z</published>
    <updated>2016-03-07T07:22:43.907Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;http://www.tinymood.com/wp-content/uploads/2016/01/2016010816333980.jpg&quot; alt=&quot;u=2568299814,2994458694&amp;amp;fm=21&amp;amp;gp=0&quot;&gt;&lt;br&gt;[hermit auto=”1” loop=”1” unexpand=”1” fullheight=”0”]netease_songs#:29719651[/hermit]&lt;/p&gt;
&lt;center&gt;&lt;span style=&quot;color: #00ccff;&quot;&gt;也许，我只是想等到一个可以温暖自己的人&lt;/span&gt;&lt;br&gt;&lt;span style=&quot;color: #00ccff;&quot;&gt; 什么事都想告诉她&lt;/span&gt;&lt;br&gt;&lt;span style=&quot;color: #00ccff;&quot;&gt; 伤心或是难过&lt;/span&gt;&lt;br&gt;&lt;span style=&quot;color: #00ccff;&quot;&gt; 快乐或是欢愉&lt;/span&gt;&lt;br&gt;&lt;span style=&quot;color: #00ccff;&quot;&gt; 没有什么其他要求&lt;/span&gt;&lt;br&gt;&lt;span style=&quot;color: #00ccff;&quot;&gt; 也不敢再有什么要求了&lt;/span&gt;&lt;br&gt;&lt;span style=&quot;color: #00ccff;&quot;&gt; 却是已经足够了&lt;/span&gt;&lt;br&gt;&lt;span style=&quot;color: #00ccff;&quot;&gt; 小小的要求&lt;/span&gt;&lt;br&gt;&lt;span style=&quot;color: #00ccff;&quot;&gt; 或许又是最难的要求&lt;/span&gt;&lt;/center&gt;

&lt;p&gt;－－Saber酱于1-8日夜夜夜的夜&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://www.tinymood.com/wp-content/uploads/2016/01/2016010816333980.jpg&quot; alt=&quot;u=2568299814,2994458694&amp;amp;fm=21&amp;amp;gp=0&quot;&gt;&lt;br&gt;[
    
    </summary>
    
      <category term="随笔" scheme="https://lemonjing.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="原创" scheme="https://lemonjing.github.io/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="爱情" scheme="https://lemonjing.github.io/tags/%E7%88%B1%E6%83%85/"/>
    
      <category term="Saber" scheme="https://lemonjing.github.io/tags/Saber/"/>
    
      <category term="温暖" scheme="https://lemonjing.github.io/tags/%E6%B8%A9%E6%9A%96/"/>
    
  </entry>
  
  <entry>
    <title>『原创』常见字符集及其分类</title>
    <link href="https://lemonjing.github.io/2016/01/15/16/"/>
    <id>https://lemonjing.github.io/2016/01/15/16/</id>
    <published>2016-01-15T14:45:42.000Z</published>
    <updated>2016-03-07T07:22:43.907Z</updated>
    
    <content type="html">&lt;p&gt;字符集编码是指对多个字符（通常在几十到几万个不等）进行整合封装成一个文件所使用的编码，外部程序通过这种编码就可以从字符集文件中调用指定的字符。我们常见的计算机字体文件就使用了字符集编码，通过输入法输入文字或者浏览网页时都会通过指定的字符集编码从字体文件中调用字符。&lt;br&gt;&lt;img src=&quot;http://www.tinymood.com/wp-content/uploads/2015/12/2015122914292984.jpg&quot; alt=&quot;9&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-以下是常见的字符集：&quot;&gt;&lt;a href=&quot;#1-以下是常见的字符集：&quot; class=&quot;headerlink&quot; title=&quot;1.以下是常见的字符集：&quot;&gt;&lt;/a&gt;1.以下是常见的字符集：&lt;/h2&gt;&lt;p&gt;&lt;span style=&quot;color: #ff6600;&quot;&gt;ASCII及其扩展字符集&lt;/span&gt;&lt;br&gt;作用：表语英语及西欧语言。 位数：ASCII是用7位表示的，能表示128个字符；其扩展使用8位表示，表示256个字符。 范围：ASCII从00到7F，扩展从00到FF。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #ff6600;&quot;&gt;ISO-8859-1字符集&lt;/span&gt;&lt;br&gt;作用：扩展ASCII，表示西欧、希腊语等。&lt;br&gt;位数：8位，&lt;br&gt;范围：从00到FF，兼容ASCII字符集。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #ff6600;&quot;&gt;Latin1&lt;/span&gt; ISO-8859-1的别名&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #ff6600;&quot;&gt;GB2312字符集&lt;/span&gt;：1981年5月1日发布的简体中文汉字编码国家标准。GB2312对汉字采用双字节编码，收录7445个图形字符，其中包括6763个汉字。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #ff6600;&quot;&gt;BIG5字符集&lt;/span&gt;：台湾地区繁体中文标准字符集，采用双字节编码，共收录13053个中文字，1984年实施。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #ff6600;&quot;&gt;GBK字符集&lt;/span&gt;：1995年12月发布的汉字编码国家标准，是对GB2312编码的扩充，对汉字采用双字节编码。GBK字符集共收录21003个汉字，包含国家标准GB13000-1中的全部中日韩汉字，和BIG5编码中的所有汉字。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #ff6600;&quot;&gt;GB18030字符集&lt;/span&gt;：2000年3月17日发布的汉字编码国家标准，是对GBK编码的扩充，覆盖中文、日文、朝鲜语和中国少数民族文字，其中收录27484个汉字。GB18030字符集采用单字节、双字节和四字节三种方式对字符编码。兼容GBK和GB2312字符集。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #ff6600;&quot;&gt;UCS字符集&lt;/span&gt;&lt;br&gt;作用：国际标准 ISO 10646 定义了通用字符集 (Universal Character Set)。它是与UNICODE同类的组织，UCS-2和UNICODE兼容&lt;br&gt;位数：它有UCS-2和UCS-4两种格式，分别是2字节和4字节&lt;br&gt;范围：目前，UCS-4只是在UCS-2前面加了0×0000&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #ff6600;&quot;&gt;Unicode字符集&lt;/span&gt;：&lt;br&gt;作用：国际标准字符集，它将世界650种语言的每个字符定义一个唯一的编码，以满足跨语言、跨平台的文本信息转换，兼容ISO-8859-1&lt;br&gt;位数：UNICODE字符集有多个编码方式，分别是UTF-8，UTF-16和UTF-32&lt;/p&gt;
&lt;h2 id=&quot;2-如何判断字符集&quot;&gt;&lt;a href=&quot;#2-如何判断字符集&quot; class=&quot;headerlink&quot; title=&quot;2.如何判断字符集&quot;&gt;&lt;/a&gt;2.如何判断字符集&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;2.1 字节序&lt;/strong&gt;&lt;br&gt;首先说一下字节序对编码的影响，字节序分为Big Endian字节序和Little Endian字节序。不同的处理器可能不一样。所以，传输时需要告诉处理器当时的编码字节序。&lt;/p&gt;
&lt;p&gt;Big Endian 大端存储：高位字节存在低地址，低字节存于高地址&lt;br&gt;Little Endian 小端存储：相反&lt;/p&gt;
&lt;p&gt;举例：0x03AB&lt;br&gt;大端存储 0000:03 0001:AB&lt;br&gt;小端存储 0000:AB 0001:03&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Java判断处理器是大端存储还是小端存储&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;prettyprint linenums&quot;&gt;public class JudgeCPUEndian {&lt;br&gt;    public static void main(String[] args) {&lt;br&gt;        if (ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) {&lt;br&gt;            System.out.println(“BIG_ENDIAN”);&lt;br&gt;        } else {&lt;br&gt;            System.out.println(“LITTLE_ENDIAN”);&lt;br&gt;        }&lt;br&gt;    }&lt;br&gt;}&lt;br&gt;&lt;/pre&gt;&lt;br&gt;&lt;span style=&quot;color: #ff6600;&quot;&gt;在我的处理器上是小端存储&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.2.编码识别&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;UNICODE，根据前几个字节可以判断UNICODE字符集的各种编码，叫做Byte Order Mask方法BOM：&lt;br&gt;UTF-8: EFBBBF&lt;br&gt;UTF-16 Big Endian：FEFF&lt;br&gt;UTF-16 Little Endian：FFFE&lt;br&gt;UTF-32 Big Endian：0000FEFF&lt;br&gt;UTF-32 Little Endian：FFFE0000&lt;/p&gt;
&lt;h2 id=&quot;3-按所表示的文字分类&quot;&gt;&lt;a href=&quot;#3-按所表示的文字分类&quot; class=&quot;headerlink&quot; title=&quot;3.按所表示的文字分类&quot;&gt;&lt;/a&gt;3.按所表示的文字分类&lt;/h2&gt;&lt;p&gt;语言 字符集 正式名称&lt;/p&gt;
&lt;p&gt;英语、西欧语 ASCII，ISO-8859-1 MBCS 多字节&lt;/p&gt;
&lt;p&gt;简体中文 GB2312 MBCS 多字节&lt;/p&gt;
&lt;p&gt;繁体中文 BIG5 MBCS 多字节&lt;/p&gt;
&lt;p&gt;简繁中文 GBK MBCS 多字节&lt;/p&gt;
&lt;p&gt;中文、日文及朝鲜语 GB18030 MBCS 多字节&lt;/p&gt;
&lt;p&gt;各国语言 UNICODE，UCS DBCS 宽字节&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;字符集编码是指对多个字符（通常在几十到几万个不等）进行整合封装成一个文件所使用的编码，外部程序通过这种编码就可以从字符集文件中调用指定的字符。我们常见的计算机字体文件就使用了字符集编码，通过输入法输入文字或者浏览网页时都会通过指定的字符集编码从字体文件中调用字符。&lt;br&gt;&lt;
    
    </summary>
    
      <category term="编织未来" scheme="https://lemonjing.github.io/categories/%E7%BC%96%E7%BB%87%E6%9C%AA%E6%9D%A5/"/>
    
    
      <category term="Coding" scheme="https://lemonjing.github.io/tags/Coding/"/>
    
      <category term="IT" scheme="https://lemonjing.github.io/tags/IT/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java注解 － 注解入门</title>
    <link href="https://lemonjing.github.io/2016/01/15/68/"/>
    <id>https://lemonjing.github.io/2016/01/15/68/</id>
    <published>2016-01-15T07:37:42.000Z</published>
    <updated>2016-03-07T07:22:43.908Z</updated>
    
    <content type="html">&lt;p&gt;要深入学习注解，我们就必须能定义自己的注解，并使用注解，在定义自己的注解之前，我们就必须要了解Java为我们提供的元注解和相关定义注解的语法。&lt;br&gt;&lt;img src=&quot;http://7xlkoc.com1.z0.glb.clouddn.com/coding2.jpg&quot; alt=&quot;插画&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Java提供的元注解&quot;&gt;&lt;a href=&quot;#Java提供的元注解&quot; class=&quot;headerlink&quot; title=&quot;Java提供的元注解&quot;&gt;&lt;/a&gt;Java提供的元注解&lt;/h2&gt;&lt;p&gt;Java5.0定义了4个标准的元注解：@Target @Retention @Documented @Inherited&lt;/p&gt;
&lt;p&gt;1.@Target注解&lt;br&gt;作用：用于描述注解的使用范围（即：被描述的注解可以用在什么地方)&lt;/p&gt;
&lt;p&gt;@Target说明了Annotation所修饰的对象范围：Annotation可被用于 packages、types（类、接口、枚举、Annotation类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数）。在Annotation类型的声明中使用了target可更加明晰其修饰的目标。&lt;/p&gt;
&lt;p&gt;取值(&lt;strong&gt;ElementType&lt;/strong&gt;)有：&lt;/p&gt;
&lt;p&gt;CONSTRUCTOR:用于描述构造器&lt;br&gt;FIELD:用于描述域&lt;br&gt;LOCAL_VARIABLE:用于描述局部变量&lt;br&gt;METHOD:用于描述方法&lt;br&gt;PACKAGE:用于描述包&lt;br&gt;PARAMETER:用于描述参数&lt;br&gt;TYPE:用于描述类、接口(包括注解类型) 或enum声明&lt;/p&gt;
&lt;p&gt;使用事例&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums&quot;&gt;
@Target(ElementType.TYPE)
public @interface Table {
    /**
     * 数据表名称注解，默认值为类名称
     * @return
     */
    public String tableName() default &quot;className&quot;;
}

@Target(ElementType.FIELD)
public @interface NoDBColumn {

}
&lt;/pre&gt;
注解Table 可以用于注解类、接口(包括注解类型) 或enum声明,而注解NoDBColumn仅可用于注解类的成员变量。

2.@Retention注解
作用：表示需要在什么级别保存该注解信息，用于描述注解的生命周期（即：被描述的注解在什么范围内有效）

@Retention定义了该Annotation被保留的时间长短：某些Annotation仅出现在源代码中，而被编译器丢弃；而另一些却被编译在class文件中；编译在class文件中的Annotation可能会被虚拟机忽略，而另一些在class被装载时将被读取（请注意并不影响class的执行，因为Annotation与class在使用上是被分离的）。使用这个meta-Annotation可以对Annotation的“生命周期”限制。

取值（**RetentionPolicy**）有：

SOURCE:在源文件中有效（即源文件保留）
CLASS:在class文件中有效（即class保留）
RUNTIME:在运行时有效（即运行时保留）
Retention meta-annotation类型有唯一的value作为成员，它的取值来自java.lang.annotation.RetentionPolicy的枚举类型值。

使用事例
&lt;pre class=&quot;prettyprint linenums&quot;&gt;
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Column {
    public String name() default &quot;fieldName&quot;;
    public String setFuncName() default &quot;setField&quot;;
    public String getFuncName() default &quot;getField&quot;; 
    public boolean defaultDBValue() default false;
}
&lt;/pre&gt;
Column注解的的RetentionPolicy的属性值是RUTIME,这样注解处理器可以通过反射，获取到该注解的属性值，从而去做一些运行时的逻辑处理

3.@Documented注解　
@Documented用于描述其它类型的annotation应该被作为被标注的程序成员的公共API，因此可以被例如javadoc此类的工具文档化。Documented是一个标记注解，没有成员。

使用事例
&lt;pre class=&quot;prettyprint linenums&quot;&gt;
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Column {
    public String name() default &quot;fieldName&quot;;
    public String setFuncName() default &quot;setField&quot;;
    public String getFuncName() default &quot;getField&quot;; 
    public boolean defaultDBValue() default false;
}
&lt;/pre&gt;
4.@Inherited注解
@Inherited元注解是一个标记注解，@Inherited阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个annotation将被用于该class的子类。

注意：@Inherited annotation类型是被标注过的class的子类所继承。类并不从它所实现的接口继承annotation，方法并不从它所重载的方法继承annotation。

当@Inherited annotation类型标注的annotation的Retention是RetentionPolicy.RUNTIME，则反射API增强了这种继承性。如果我们使用java.lang.reflect去查询一个@Inherited annotation类型的annotation时，反射代码检查将展开工作：检查class和其父类，直到发现指定的annotation类型被发现，或者到达类继承结构的顶层。

使用事例
&lt;pre class=&quot;prettyprint linenums&quot;&gt;
/**
 * 
 * @author taoxiaoran
 *
 */
@Inherited
public @interface Greeting {
    public enum FontColor{ BULE,RED,GREEN};
    String name();
    FontColor fontColor() default FontColor.GREEN;
}
&lt;/pre&gt;

&lt;h2 id=&quot;自定义注解&quot;&gt;&lt;a href=&quot;#自定义注解&quot; class=&quot;headerlink&quot; title=&quot;自定义注解&quot;&gt;&lt;/a&gt;自定义注解&lt;/h2&gt;&lt;p&gt;使用@interface自定义注解时，自动继承了java.lang.annotation.Annotation接口，由编译程序自动完成其他细节。在定义注解时，不能继承其他的注解或接口。@interface用来声明一个注解，其中的每一个方法实际上是声明了一个配置参数。方法的名称就是参数的名称，返回值类型就是参数的类型（返回值类型只能是基本类型、Class、String、enum）。可以通过default来声明参数的默认值。&lt;/p&gt;
&lt;p&gt;定义注解格式： public @interface 注解名 {定义体}&lt;/p&gt;
&lt;p&gt;注解参数的可支持数据类型：&lt;/p&gt;
&lt;p&gt;所有基本数据类型（int,float,boolean,byte,double,char,long,short)&lt;br&gt;String类型&lt;br&gt;Class类型&lt;br&gt;enum类型&lt;br&gt;Annotation类型&lt;br&gt;以上所有类型的数组&lt;br&gt;Annotation类型里面的参数该怎么设定:&lt;/p&gt;
&lt;p&gt;只能用public或默认(default)这两个访问权修饰.例如,String value();这里把方法设为defaul默认类型；　 　&lt;br&gt;参数成员只能用基本类型byte,short,char,int,long,float,double,boolean八种基本数据类型和 String,Enum,Class,annotations等数据类型,以及这一些类型的数组.例如,String value();这里的参数成员就为String;　　&lt;br&gt;如果只有一个参数成员,最好把参数名称设为”value”,后加小括号.例:下面的例子FruitName注解就只有一个参数成员。&lt;br&gt;简单的自定义注解和使用注解实例：&lt;/p&gt;
&lt;pre class=&quot;prettyprint linenums&quot;&gt;
package annotation;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * 水果名称注解
 * @author taoxiaoran
 *
 */
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface FruitName {
    String value() default &quot;&quot;;
}
&lt;/pre&gt;

&lt;pre class=&quot;prettyprint linenums&quot;&gt;
package annotation;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * 水果颜色注解
 * @author taoxiaoran
 *
 */
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface FruitColor {
    /**
     * 颜色枚举
     * @author taoxiaoran
     *
     */
    public enum Color{ BULE,RED,GREEN};

    /**
     * 颜色属性
     * @return
     */
    Color fruitColor() default Color.GREEN;

}
&lt;/pre&gt;
&lt;pre class=&quot;prettyprint linenums&quot;&gt;
package annotation;

import annotation.FruitColor.Color;

public class Apple {

    @FruitName(&quot;Apple&quot;)
    private String appleName;

    @FruitColor(fruitColor=Color.RED)
    private String appleColor;

    public void setAppleColor(String appleColor) {
        this.appleColor = appleColor;
    }

    public String getAppleColor() {
        return appleColor;
    }

    public void setAppleName(String appleName) {
        this.appleName = appleName;
    }

    public String getAppleName() {
        return appleName;
    }

    public void displayName(){
        System.out.println(&quot;水果的名字是：苹果&quot;);
    }
}
&lt;/pre&gt;

&lt;h2 id=&quot;注解元素的默认值&quot;&gt;&lt;a href=&quot;#注解元素的默认值&quot; class=&quot;headerlink&quot; title=&quot;注解元素的默认值&quot;&gt;&lt;/a&gt;注解元素的默认值&lt;/h2&gt;&lt;p&gt;注解元素必须有确定的值，要么在定义注解的默认值中指定，要么在使用注解时指定，非基本类型的注解元素的值不可为null。因此, 使用空字符串或0作为默认值是一种常用的做法。这个约束使得处理器很难表现一个元素的存在或缺失的状态，因为每个注解的声明中，所有元素都存在，并且都具有相应的值，为了绕开这个约束，我们只能定义一些特殊的值，例如空字符串或者负数，以此表示某个元素不存在，在定义注解时，这已经成为一个习惯用法。例如：&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;prettyprint linenums&quot;&gt;&lt;br&gt;package annotation;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;import java.lang.annotation.Documented;&lt;br&gt;import java.lang.annotation.ElementType;&lt;br&gt;import java.lang.annotation.Retention;&lt;br&gt;import java.lang.annotation.RetentionPolicy;&lt;br&gt;import java.lang.annotation.Target;&lt;/p&gt;
&lt;p&gt;/**&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;水果供应者注解&lt;/li&gt;
&lt;li&gt;&lt;p&gt;@author taoxiaoran&lt;br&gt;&lt;em&gt;
&lt;/em&gt;/&lt;br&gt;@Target(ElementType.FIELD)&lt;br&gt;@Retention(RetentionPolicy.RUNTIME)&lt;br&gt;@Documented&lt;br&gt;public @interface FruitProvider {&lt;br&gt; /**&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;供应商编号&lt;/li&gt;
&lt;li&gt;&lt;p&gt;@return&lt;br&gt;*/&lt;br&gt;public int id() default -1;&lt;/p&gt;
&lt;p&gt;/**&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;供应商名称&lt;/li&gt;
&lt;li&gt;&lt;p&gt;@return&lt;br&gt;*/&lt;br&gt;public String name() default “”;&lt;/p&gt;
&lt;p&gt;/**&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;供应商地址&lt;/li&gt;
&lt;li&gt;@return&lt;br&gt;*/&lt;br&gt;public String address() default “”;&lt;br&gt;}&lt;br&gt;&lt;br&gt;定义了注解，并在需要的时候给相关类，类属性加上注解信息，如果没有响应的注解信息处理流程，注解可以说是没有实用价值。如何让注解真真的发挥作用，主要就在于注解处理方法，下一步我们将学习注解信息的获取和处理！&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文转自博客园 地址 &lt;a href=&quot;http://www.cnblogs.com/peida&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/peida&lt;/a&gt; 本人略有修改。2015-11-2&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;要深入学习注解，我们就必须能定义自己的注解，并使用注解，在定义自己的注解之前，我们就必须要了解Java为我们提供的元注解和相关定义注解的语法。&lt;br&gt;&lt;img src=&quot;http://7xlkoc.com1.z0.glb.clouddn.com/coding2.jpg&quot; a
    
    </summary>
    
      <category term="编织未来" scheme="https://lemonjing.github.io/categories/%E7%BC%96%E7%BB%87%E6%9C%AA%E6%9D%A5/"/>
    
    
      <category term="Java" scheme="https://lemonjing.github.io/tags/Java/"/>
    
      <category term="annotation" scheme="https://lemonjing.github.io/tags/annotation/"/>
    
      <category term="注解" scheme="https://lemonjing.github.io/tags/%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>我只知道 如若是你 随时随地 我会如约而至</title>
    <link href="https://lemonjing.github.io/2016/01/13/53/"/>
    <id>https://lemonjing.github.io/2016/01/13/53/</id>
    <published>2016-01-13T15:07:46.000Z</published>
    <updated>2016-03-07T07:22:43.908Z</updated>
    
    <content type="html">&lt;p&gt;世界上只有两种可以称之为浪漫的情感：一种叫相濡以沫，另一种叫相忘于江湖。&lt;/p&gt;
&lt;p&gt;我们要做的是争取和最爱的人相濡以沫，和次爱的人相忘于江湖。&lt;/p&gt;
&lt;p&gt;所有的时光都是被辜负被浪费后，才能从记忆里将某一段拎出，拍拍上面沉积的灰尘，感叹它是最好的时光。&lt;/p&gt;
&lt;p&gt;人生最好的旅行，就是你在一个陌生的地方，发现一种久违的感动。&lt;/p&gt;
&lt;p&gt;如果你能看到我的世界里那些渐渐消逝的美好，你就能体会到现在所拥有的幸福。&lt;/p&gt;
&lt;p&gt;我们总以为，想要的幸福，是在光阴的对岸，其实，幸福就淹没在这流年的急景中，从未曾远离。&lt;/p&gt;
&lt;p&gt;我不管前方是风是雨还是晴，我只知道，如若是你，随时随地，我会如约而至，哪怕赌上一生的运气。&lt;/p&gt;
&lt;p&gt;人的一生要疯狂一次，无论是为一个人，一段情，一段路途或一个梦想。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;世界上只有两种可以称之为浪漫的情感：一种叫相濡以沫，另一种叫相忘于江湖。&lt;/p&gt;
&lt;p&gt;我们要做的是争取和最爱的人相濡以沫，和次爱的人相忘于江湖。&lt;/p&gt;
&lt;p&gt;所有的时光都是被辜负被浪费后，才能从记忆里将某一段拎出，拍拍上面沉积的灰尘，感叹它是最好的时光。&lt;/p&gt;
&lt;p&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://lemonjing.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="爱情" scheme="https://lemonjing.github.io/tags/%E7%88%B1%E6%83%85/"/>
    
      <category term="少年" scheme="https://lemonjing.github.io/tags/%E5%B0%91%E5%B9%B4/"/>
    
  </entry>
  
  <entry>
    <title>遇见更好的人时却已用完了最好的自己</title>
    <link href="https://lemonjing.github.io/2016/01/13/73/"/>
    <id>https://lemonjing.github.io/2016/01/13/73/</id>
    <published>2016-01-13T14:49:38.000Z</published>
    <updated>2016-03-07T07:22:43.907Z</updated>
    
    <content type="html">&lt;p&gt;[hermit auto=”1” loop=”1” unexpand=”1” fullheight=”0”]netease_songs#:186149[/hermit]&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-family:宋体; font-size:12pt&quot;&gt;1、我是一只瓶子，装满叫感情的液体。&lt;br&gt;&lt;img src=&quot;http://www.tinymood.com/wp-content/uploads/2016/01/011316_1447_1.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;span style=&quot;color:#595959&quot;&gt;2、我救过一条奄奄一息的金鱼。&lt;br&gt;&lt;img src=&quot;http://www.tinymood.com/wp-content/uploads/2016/01/011316_1447_2.jpg&quot; alt=&quot;&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;img src=&quot;http://www.tinymood.com/wp-content/uploads/2016/01/011316_1447_3.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;span style=&quot;color:#595959&quot;&gt;3、但我忘了，金鱼的记忆只有七秒钟。&lt;br&gt;&lt;img src=&quot;http://www.tinymood.com/wp-content/uploads/2016/01/011316_1447_4.jpg&quot; alt=&quot;&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span style=&quot;color:#595959&quot;&gt;4、直到放他走的那一天…&lt;br&gt;&lt;/span&gt;&lt;br&gt;&lt;span style=&quot;color:#595959&quot;&gt;5、后来我遇见了小海绵。&lt;br&gt;&lt;/span&gt;&lt;br&gt;&lt;span style=&quot;color:#595959&quot;&gt;6、烈日下的他被烤成紧巴巴的一团。&lt;br&gt;&lt;img src=&quot;http://www.tinymood.com/wp-content/uploads/2016/01/011316_1447_5.jpg&quot; alt=&quot;&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span style=&quot;color:#595959&quot;&gt;7、我救了他，于是我们成了好朋友。&lt;br&gt;&lt;img src=&quot;http://www.tinymood.com/wp-content/uploads/2016/01/011316_1447_6.jpg&quot; alt=&quot;&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span style=&quot;color:#595959&quot;&gt;8、可是我知道&lt;br&gt;&lt;img src=&quot;http://www.tinymood.com/wp-content/uploads/2016/01/011316_1447_7.jpg&quot; alt=&quot;&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span style=&quot;color:#595959&quot;&gt;9、朋友&lt;br&gt;&lt;img src=&quot;http://www.tinymood.com/wp-content/uploads/2016/01/011316_1447_8.jpg&quot; alt=&quot;&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span style=&quot;color:#595959&quot;&gt;10、绝对不是一味的索取。&lt;br&gt;&lt;img src=&quot;http://www.tinymood.com/wp-content/uploads/2016/01/011316_1447_9.jpg&quot; alt=&quot;&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span style=&quot;color:#595959&quot;&gt;11、在我最困难的时候，是仙人球先生一直陪着我&lt;br&gt;&lt;img src=&quot;http://www.tinymood.com/wp-content/uploads/2016/01/011316_1447_10.jpg&quot; alt=&quot;&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span style=&quot;color:#595959&quot;&gt;12、我义无反顾的跟着他，来到他的家乡，沙漠&lt;br&gt;&lt;img src=&quot;http://www.tinymood.com/wp-content/uploads/2016/01/011316_1447_11.jpg&quot; alt=&quot;&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span style=&quot;color:#595959&quot;&gt;13、可是我渐渐发现&lt;br&gt;&lt;img src=&quot;http://www.tinymood.com/wp-content/uploads/2016/01/011316_1447_12.jpg&quot; alt=&quot;&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span style=&quot;color:#595959&quot;&gt;14、我视若生命的东西，是他不需要的&lt;br&gt;&lt;img src=&quot;http://www.tinymood.com/wp-content/uploads/2016/01/011316_1447_13.jpg&quot; alt=&quot;&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span style=&quot;color:#595959&quot;&gt;15、不需要，也就不重要了吧&lt;br&gt;&lt;img src=&quot;http://www.tinymood.com/wp-content/uploads/2016/01/011316_1447_14.jpg&quot; alt=&quot;&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span style=&quot;color:#595959&quot;&gt;16、我一直在想，如果命运早点安排冰糖先生出现该多好&lt;br&gt;&lt;img src=&quot;http://www.tinymood.com/wp-content/uploads/2016/01/011316_1447_15.jpg&quot; alt=&quot;&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span style=&quot;color:#595959&quot;&gt;17、和他在一起的每一天，都会是甜甜的吧？&lt;br&gt;&lt;img src=&quot;http://www.tinymood.com/wp-content/uploads/2016/01/011316_1447_16.jpg&quot; alt=&quot;&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span style=&quot;color:#595959&quot;&gt;18、只是，此刻的我才明白，最大的遗憾不是错过最好的人&lt;br&gt;&lt;img src=&quot;http://www.tinymood.com/wp-content/uploads/2016/01/011316_1447_17.jpg&quot; alt=&quot;&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span style=&quot;color:#595959&quot;&gt;19、而是，当你遇见更好的人时&lt;br&gt;&lt;img src=&quot;http://www.tinymood.com/wp-content/uploads/2016/01/011316_1447_18.jpg&quot; alt=&quot;&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span style=&quot;color:#595959&quot;&gt;20、已经把最好的自己用完了。&lt;br&gt;&lt;img src=&quot;http://www.tinymood.com/wp-content/uploads/2016/01/011316_1447_19.jpg&quot; alt=&quot;&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span style=&quot;color:#595959&quot;&gt;21、感情是易耗品，只愿你，把最好的自己，留给对的人。只是我们都只是在经历了一切之后才明白这一点，常常，没能把最好的自己交给那个最对的人。&lt;br&gt;&lt;img src=&quot;http://www.tinymood.com/wp-content/uploads/2016/01/011316_1447_20.jpg&quot; alt=&quot;&quot;&gt;&lt;/span&gt;&lt;br&gt;        &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color:#59c3f9; font-family:宋体&quot;&gt;&lt;span style=&quot;font-size:13pt&quot;&gt;&lt;strong&gt;读而思&lt;/strong&gt;&lt;/span&gt;&lt;span style=&quot;font-size:15pt&quot;&gt;&lt;br&gt;            &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color:#59c3f9; font-family:宋体; font-size:12pt&quot;&gt;我还等得起，在还未向岁月认输之前。这世上一切孤独的等待我都等得起。因为我相信，未来的某个日子，你会摘一朵我最爱的栀子花，穿着我最喜爱的格子衬衫，帆布鞋，笑眯眯的递给我，然后温柔的说，不好意思，让你多等了。以后的日子里，我陪你走过春夏秋冬，陪你花好月圆，陪你细水长流。&lt;/span&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;[hermit auto=”1” loop=”1” unexpand=”1” fullheight=”0”]netease_songs#:186149[/hermit]&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-family:宋体; font-size:12pt&quot;&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://lemonjing.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="爱情" scheme="https://lemonjing.github.io/tags/%E7%88%B1%E6%83%85/"/>
    
      <category term="画" scheme="https://lemonjing.github.io/tags/%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>时间太瘦，指缝太宽</title>
    <link href="https://lemonjing.github.io/2016/01/12/79/"/>
    <id>https://lemonjing.github.io/2016/01/12/79/</id>
    <published>2016-01-12T13:02:54.000Z</published>
    <updated>2016-03-07T07:22:43.907Z</updated>
    
    <content type="html">&lt;p&gt;&lt;center&gt;🌸个人公众号小情绪xiaoqingxu 2015-05-20 收录&lt;/center&gt;&lt;br&gt;[hermit auto=”1” loop=”1” unexpand=”1” fullheight=”0”]netease_songs#:186010[/hermit]&lt;br&gt;4月4日-4月7日，4天3夜，杭州西溪湿地，阴雨两天两夜。&lt;/p&gt;
&lt;p&gt;带着猪先生去度假，再次约了李先生和虞小姐夫妇同行，只是这次多了小小李。&lt;/p&gt;
&lt;p&gt;阴雨连绵，所以这三天都是以酒店、餐厅和咖啡馆为主，像极了我们4个第一次同行毛里求斯的行程。不知道是因为场景太像毛里求斯而来的怀念，还是因为多了小小李的缘故，过去几年的片段像影片一样一帧一帧地过脑重现。&lt;/p&gt;
&lt;p&gt;这几年，我们和李先生一家一起去了毛里求斯、迪拜、丽江、重庆、台湾和韩国，他们常居魔都，我们久住帝都。我们有个微信群叫下一站去哪里，每次出发一个地方，群名就随之有个诗意的名字。&lt;/p&gt;
&lt;p&gt;能有一对合拍的旅友是一件幸事。我们都不太愿意赶景点，不太计较各种琐碎，有时候情愿坐在咖啡厅，有的没的聊一聊，看看当地风土人情。都是资深吃货，唯独我算个半个专业玩儿家，有时侯想走走看看，就自己背包上路，不需要猪先生陪。&lt;/p&gt;
&lt;p&gt;韩国江原道，李先生和虞小姐告诉了我们小小李的存在，那个时候他们也刚刚知道一周左右。出于小小李的安全考虑，我们分开行动，我和猪先生自己去了首尔吃香的喝辣的，虞小姐在江原道吐得天昏地暗，李先生束手无策；去年清明节，我和猪先生去魔都，虞小姐顶着大肚皮，在等一个月后和小小李的见面；整整一年，李先生虞小姐升级；我和猪先生也孕育出了自己的公司；直到今天，小小李坐在我们的面前，手舞足蹈，咿咿呀呀，李先生和虞小姐忙的四脚朝天，虞小姐再也参加不了我们的夜生活，居酒屋喝喝小酒，吹吹小风，再无体验假装在东京的风雅。&lt;/p&gt;
&lt;p&gt;时间就是这样，划过我们的皮肤却没有一丝痕迹。&lt;/p&gt;
&lt;p&gt;猪先生很辛苦，这几天他基本是在酒店睡过来的。饭点时，我会带他们去吃各种我做攻略找到的好吃的。猪先生心态极好，天大的事，依旧能吃能睡，从不向我抱怨一句。李先生是个投行班客儿，假期期间仍然不断地接着工作电话，收着工作邮件。大家都清醒的时候，总会喝喝咖啡冲冲茶，话题多半还是和工作公司有关，对于猪先生和李先生之间的这种革命情谊和工作节奏，我早已适应；我和虞小姐会拉拉家常，小小李满地爬，啃啃我们的鞋子抱抱我们的腿。&lt;/p&gt;
&lt;p&gt;昨晚我开始失眠。结束假期前，只要想到工作，我一向会失眠。4月的工作日程基本满的找不到时间的空白，除了焦虑没办法找到第二种情绪。索性爬起来打开电脑，理了理思绪，找了找资料，情绪才开始慢慢平静。&lt;/p&gt;
&lt;p&gt;说不清楚从什么时候，厌烦这种被时间追着走，被一个个deadline倒逼的状态。2014年做了很多事，没有一场旅行，没看一场话剧，没去一场展览，年底时并不觉得开心。一度看到鸡血文就心生厌烦，对社会评价深恶痛绝。每一天我都会问自己，你在做什么，你想要什么？&lt;/p&gt;
&lt;p&gt;从年初到现在，我身边不断有朋友经历着父母身患重病，甚至离世，经历着自己的生活不断地让位于孩子的成长，经历着职业的一次一次暴风雨般的变动，总有屋漏偏逢连夜雨的无奈和无力。我的每一天，遇到问题，解决问题，再遇到新问题的周而复始，每次都会问，擦，还会更坏更糟吗？想好最坏的结果，然后闭上眼睛，翻来覆去直到能睡过去，但更坏更糟的真的出现时，发现也不过如此。&lt;/p&gt;
&lt;p&gt;以前总是觉得上有老，下有小，每天像乌龟的日子距离我们好远。当我娘开始累的走不动路，小小李抱着我的腿傻笑，我每天甚至一年都没有时间去想再做一个伪文艺青年时，这一天就这样悄无声息的来了，其实，它早就早就来了。&lt;/p&gt;
&lt;p&gt;今年春节，我带着爸妈旅行，有很多个瞬间我觉得他们真的老了。那两个在近30年给我力量和勇气的最亲近的人，时时需要我成为他们的支柱；那两个以前我要看他们脸色的人，现在开始因为我表情的微小变化而揣度我的情绪行事；角色的互换就这样无声无息的发生了。返程的飞机上我望着窗外哭的一塌糊涂，我要挣很多很多的钱，我要在他们还没有完全老去，能走得动，能吃的下的时候，带他们去住最好的酒店，坐舒服的头等舱，吃各种新鲜的美食。&lt;/p&gt;
&lt;p&gt;对，我就是个俗人，我就是要做个有钱人。别再逼逼那些有的没的，有了钱再去谈文艺，有了经济基础再去扯那些精神建筑。&lt;/p&gt;
&lt;p&gt;2015年过去了三分之一，我用3个月的时间纠结一件事，在杭州这几天好像一切都释然了。抗拒压力的最大原因，说到底还是能力撑不起自己的野心。对自己的怜香惜玉说到底是内心的无力和无奈，想要的太多，愿意付出的却太少。我们不敢做的事，让我们紧张和胆怯的事，往往是因为我们能力达不到，但我们至少要考虑清楚是待在原地逃避还是勇敢再向前跨出一步。&lt;/p&gt;
&lt;p&gt;我们想要的东西往往高高在上遥遥无期，有时候甚至就是个无底洞。对于那些不能立竿见影的结果，确实磨练我们的意志和耐心。我们都不是完人，我们可以犹豫可以歇，可以矫情可以作，就像我这3个月，但是一定要自己走出来，别把自己的逃避和懦弱当做不接地气的惺惺相惜。&lt;/p&gt;
&lt;p&gt;今早和李先生虞小姐吃过早饭，就要说再见。吃饭时，李先生说，昨晚我们分开后，他去咖啡馆工作了3个小时。工作前心情烦躁的要死，工作完觉得好多了。我说，同感。看着日程表上的工作安排焦虑的坐立不安，坐下来开始着手其中某一项才能安心，开始做，就是一个分界点。&lt;/p&gt;
&lt;p&gt;所以，做一只愉快的上班狗吧。好好吃饭，好好睡觉，文艺地生活，苦逼的工作，生活就是这样，每一个人都逃不过这一课。&lt;/p&gt;
&lt;p&gt;时间太瘦，指缝太宽。叨逼叨是最无用的选择。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.tinymood.com/wp-content/uploads/2016/01/2016011213023493.jpg&quot; alt=&quot;21321&quot;&gt;&lt;br&gt;上午在花间堂的猫的天空书店，看到了一张明信片。上面那段话我很喜欢：&lt;/p&gt;
&lt;p&gt;[v_act]在远方 这是一种诗意的距离&lt;/p&gt;
&lt;p&gt;海子说“远在远方的风比远方更远”&lt;/p&gt;
&lt;p&gt;走多远才算远方也许只有风知道&lt;/p&gt;
&lt;p&gt;但请告诉我&lt;/p&gt;
&lt;p&gt;多么冷静&lt;/p&gt;
&lt;p&gt;才能像稻草人坚守自己的麦田&lt;/p&gt;
&lt;p&gt;多少坚持&lt;/p&gt;
&lt;p&gt;能抵制红尘纷扰 不理睬的风情眉头鬓上&lt;/p&gt;
&lt;p&gt;承诺是最远的一条路 因为有太多要逃避的路口[/v_act]&lt;/p&gt;
&lt;p&gt;图片｜澳大利亚 Pink Lake&lt;br&gt;摄影｜N74photography Mr.Cheese&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;center&gt;🌸个人公众号小情绪xiaoqingxu 2015-05-20 收录&lt;/center&gt;&lt;br&gt;[hermit auto=”1” loop=”1” unexpand=”1” fullheight=”0”]netease_songs#:186010[/hermi
    
    </summary>
    
      <category term="小情绪" scheme="https://lemonjing.github.io/categories/%E5%B0%8F%E6%83%85%E7%BB%AA/"/>
    
      <category term="随笔" scheme="https://lemonjing.github.io/categories/%E5%B0%8F%E6%83%85%E7%BB%AA/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="爱情" scheme="https://lemonjing.github.io/tags/%E7%88%B1%E6%83%85/"/>
    
      <category term="时间" scheme="https://lemonjing.github.io/tags/%E6%97%B6%E9%97%B4/"/>
    
  </entry>
  
</feed>
